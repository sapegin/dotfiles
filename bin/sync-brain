#!/usr/bin/env node

// Generates Dash docset with:
// - [x] Washing code book
// - [x] Blog
// - [ ] Writing drafts
//
// ---
// Author: Artem Sapegin, sapegin.me
// License: MIT
// https://github.com/sapegin/dotfiles

/*
Dash docset configuration

1. Open Settings → Downloads → Docset Generator
2. Create a new docset
3. Local documentation files
4. Folder: ~/dotfiles/brain
5. Name: Brain, keyword: me
6. Custom index
7. Copy the code below:

// Index each file by its page title
const name = $("title").text();
const type = document.querySelector('meta[name="type"]').getAttribute('content');
dashDoc.addEntry({ name, type });

// Indexing each section
const shouldIndexSubsections = document.querySelector('meta[name="subsections"]').getAttribute('content');
if (shouldIndexSubsections === 'yes') {
    document.querySelectorAll('h2').forEach(function(heading) {
        const title = heading.textContent;
        const hash = title.replace(/\W/g, '');
        heading.setAttribute('id', hash);
        dashDoc.addEntry({name: title, type: 'Section', hash});
    });
}

8. CSS: Skip for now
*/

import path from 'node:path';
import os from 'node:os';
import fs from 'node:fs';
import { execSync } from 'node:child_process';
import { globSync } from 'glob';
import remarkParse from 'remark-parse';
import remarkRehype from 'remark-rehype';
import rehypeStringify from 'rehype-stringify';
import rehypeShiki from '@shikijs/rehype';
import { unified } from 'unified';
import rehypeShikiFromHighlighter from '@shikijs/rehype/core';
import { createHighlighterCore } from 'shiki/core';
import { createOnigurumaEngine } from 'shiki/engine/oniguruma';

// TODO: How to add an icon? Raccoon!
// TODO: Get rid of 020, 040...

const HOME = os.homedir();

const BOOK_REPO_TAR_GZ =
	'https://codeload.github.com/sapegin/washingcode-book/tar.gz/master';
const BLOG_REPO_TAR_GZ =
	'https://codeload.github.com/sapegin/sapegin.me/tar.gz/master';

const BOOK_SOURCE_DIR = `${HOME}/dotfiles/washingcode-book-master`;
const BLOG_SOURCE_DIR = `${HOME}/dotfiles/sapegin.me-master`;
const DEST_DIR = `${HOME}/dotfiles/brain`;
const SITE_URL = 'https://sapegin.me/';

const TIPS = {
	I: 'Info',
	W: 'Warning',
	E: 'Error',
	T: 'Tip',
};

const highlighter = await createHighlighterCore({
	themes: [
		import('../colors/shiki/SquirrelsongLight.color-theme.json', {
			with: { type: 'json' },
		}),
	],
	langs: [
		import('@shikijs/langs/css'),
		import('@shikijs/langs/html'),
		import('@shikijs/langs/javascript'),
		import('@shikijs/langs/json'),
		import('@shikijs/langs/jsx'),
		import('@shikijs/langs/markdown'),
		import('@shikijs/langs/pascal'),
		import('@shikijs/langs/php'),
		import('@shikijs/langs/python'),
		import('@shikijs/langs/tsx'),
		import('@shikijs/langs/typescript'),
	],
	engine: createOnigurumaEngine(() => import('shiki/wasm')),
});

function read(file) {
	return fs.readFileSync(file, 'utf8');
}

function write(file, text) {
	return fs.writeFileSync(file, text);
}

function getTitle(text) {
	return text.match(/#\s+([^\n]+)/m)?.[1] ?? '';
}

function replaceFrontMatter(text) {
	return text.replace(/^---\n([\s\S]*?)\n---\n/, (match, frontmatter) => {
		const titleMatch = frontmatter.match(/^title:\s*['"]?([^'"'\n]+)['"]?$/m);
		const title = titleMatch ? titleMatch[1] : '';
		return title ? `# ${title}\n\n` : '';
	});
}

function stripIds(contents) {
	return contents.replaceAll(/\n?{#[^\n]+}\n$/gm, '');
}

// /blog/foo → https://sapegin.me/blog/foo
function updateLinksAbsolute(contents) {
	return contents.replaceAll('](/', `](${SITE_URL}/`);
}

// images/ → https://sapegin.me/images/blog/book/
function updateImagesAbsolute(contents) {
	return contents.replaceAll('](images/', `](${SITE_URL}/images/blog/book/`);
}

function stripInternalLinks(contents) {
	return contents.replaceAll(/\[(.*?)]\(#(.*?)\)/g, (_match, title) => {
		return title;
	});
}

function updateTips(contents) {
	const keysMask = Object.keys(TIPS).join('');
	return (
		contents
			// Replace paragraph breaks inside tips with double <br>
			.replaceAll(
				new RegExp(`\\s*([${keysMask}])>\\s*([${keysMask}])>\\s*`, 'gm'),
				'<br><br>'
			)
			// Replace the first tip marker in a block with a text marker (**Info:**)
			.replaceAll(
				new RegExp(`\\n([${keysMask}])> `, 'gm'),
				(_match, marker) => {
					return `\n**${TIPS[marker]}:** `;
				}
			)
	);
}

function wrapHtml(body, { title, type, subsections }) {
	return `<!DOCTYPE html>
  <html lang="en">
    <head>
      <title>${title}</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
      <meta name="type" content="${type}">
      <meta name="subsections" content="${subsections ? 'yes' : 'no'}">
      <link rel="stylesheet" href="../styles/styles.css">
    </head>
    <body>
      ${body}
    </body>
  </html>
  `;
}

function prepareMarkdown(md) {
	return updateImagesAbsolute(
		updateLinksAbsolute(
			updateTips(stripInternalLinks(stripIds(replaceFrontMatter(md))))
		)
	);
}

async function markdownToHtml(
	md,
	{
		// https://kapeli.com/docsets#supportedentrytypes
		type,
		// Index subsections as separate documentation entries
		subsections,
	}
) {
	const html = await unified()
		.use(remarkParse)
		.use(remarkRehype)
		.use(rehypeShikiFromHighlighter, highlighter, {
			theme: 'Squirrelsong Light',
		})
		.use(rehypeStringify)
		.process(md);

	return wrapHtml(html, {
		title: getTitle(md),
		type,
		subsections,
	});
}

async function addMarkdownFolder(
	dir,
	{ destDir, type, subsections = false, filter = () => true }
) {
	const files = globSync(`${dir}/**/*.md`);
	const destDirFull = `${DEST_DIR}/${destDir}`;
	fs.rmSync(destDirFull, { recursive: true, force: true });
	fs.mkdirSync(destDirFull, { recursive: true, force: true });

	for (const file of files) {
		if (filter(file) === false) {
			continue;
		}

		console.log('👉🏼', file);
		const md = read(file);
		const cleanMd = prepareMarkdown(md);
		const html = await markdownToHtml(cleanMd, { type, subsections });
		const filename = path.parse(file).name;
		write(`${destDirFull}/${filename}.html`, html);
	}
}

console.log('📖 Downloading the book…');

// fs.rmSync(BOOK_SOURCE_DIR, { recursive: true, force: true });
// execSync(`curl "${BOOK_REPO_TAR_GZ}" | tar xz -C $HOME/dotfiles`);

console.log();
console.log('📖 Generating the book files…');

await addMarkdownFolder(`${BOOK_SOURCE_DIR}/manuscript`, {
	destDir: 'book',
	type: 'Guide',
	subsections: true,
	filter: (x) =>
		x.includes('Header') === false && x.includes('Footer') === false,
});

console.log('👨🏻‍💻 Downloading the blog…');

fs.rmSync(BLOG_SOURCE_DIR, { recursive: true, force: true });
execSync(`curl "${BLOG_REPO_TAR_GZ}" | tar xz -C $HOME/dotfiles`);

console.log();
console.log('👨🏻‍💻 Generating the blog files…');

await addMarkdownFolder(`${BLOG_SOURCE_DIR}/src/content/blog`, {
	destDir: 'blog',
	type: 'Guide',
	filter: (x) => x.includes('hello-world') === false,
});

console.log();
console.log('🦜 Now update the docset in Dash:');
console.log(
	'Go to Settings → Downloads → Docset Generator and run Update Docset'
);
