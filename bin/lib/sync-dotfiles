#!/usr/bin/env node

/* eslint-disable no-await-in-loop */

// Makes symlinks for dotfiles: ~/dotfiles/tilde/.bashrc => ~/.bashrc.
//
// Author: Artem Sapegin, sapegin.me
// License: MIT
// https://github.com/sapegin/dotfiles
//

import os from 'node:os';
import path from 'node:path';
import fs from 'node:fs';
import readline from 'node:readline';
import { globSync } from 'glob';

const QUESTION_MARK = '\x1b[33m?\x1b[0m';
const HOME = os.homedir();
const TILDE_DIR = `${HOME}/dotfiles/tilde`;
const IGNORE = ['.DS_Store', 'Brewfile.lock.json'];
const SPECIALS = [
	{
		// Convenience symlink: iCloud Documents
		source: `${HOME}/Library/Mobile Documents/com~apple~CloudDocs`,
		destination: `${HOME}/cloud`,
	},
	{
		// Convenience symlink: Obsidian vault
		source: `${HOME}/Library/Mobile Documents/iCloud~md~obsidian/Documents/Murder`,
		destination: `${HOME}/murder`,
	},
	{
		// Visual Studio Code
		source: `${HOME}/dotfiles/vscode/User`,
		destination: `${HOME}/Library/Application Support/Code/User`,
	},
	{
		// Cursor
		source: `${HOME}/dotfiles/vscode/Cursor`,
		destination: `${HOME}/Library/Application Support/Cursor/User`,
	},
	{
		// Kilo Code rules
		source: `${HOME}/dotfiles/ai-rules/rules`,
		destination: `${HOME}/.kilocode/rules`,
	},
	{
		// Kilo Code commands
		source: `${HOME}/dotfiles/ai-rules/commands`,
		destination: `${HOME}/.kilocode/workflows`,
	},
	{
		// Cursor commands.
		// Need to be copied, doesn't work with symlinks
		source: `${HOME}/dotfiles/ai-rules/commands/review.prompt.md`,
		destination: `${HOME}/.cursor/commands/review.md`,
		copy: true,
	},
	{
		// Photoshop
		source: `${HOME}/Library/Mobile Documents/com~apple~CloudDocs/Apps/Adobe Photoshop 2024 Settings`,
		destination: `${HOME}/Library/Preferences/Adobe Photoshop 2024 Settings`,
	},
];

function isSymlinkTo(link, dest) {
	const statLink = fs.lstatSync(link);
	if (statLink.isSymbolicLink() === false) {
		return false;
	}

	return fs.realpathSync(link) === fs.realpathSync(dest);
}

async function confirmAction(message) {
	const rl = readline.createInterface({
		input: process.stdin,
		output: process.stdout,
	});

	return new Promise((resolve) => {
		rl.question(`${QUESTION_MARK} ${message} (y/N): `, (answer) => {
			rl.close();
			const response = answer.toLowerCase().trim();
			resolve(response === 'y' || response === 'yes');
		});
	});
}

async function syncDotfiles() {
	process.chdir(TILDE_DIR);
	const files = [
		// Sync all files in tilde/ folder
		...globSync('*', { dot: true, nodir: true }),
		// Sync additional config _folders_ in .config/ folder
		...globSync('.config/*'),
		// Sync additional Cursor config files (but don't overwrite other files)
		...globSync('.cursor/**/*', { dot: true, nodir: true }),
	];

	for (const sourceFile of files) {
		const sourcePath = `${TILDE_DIR}/${sourceFile}`;
		const destPath = `${HOME}/${sourceFile}`;

		if (IGNORE.includes(sourceFile)) {
			continue;
		}

		// Check that we aren't overwriting anything
		if (fs.existsSync(destPath)) {
			// Already a symlink to dotfiles?
			if (isSymlinkTo(destPath, sourcePath)) {
				continue;
			}

			// Should overwrite?
			const shouldOverwrite = await confirmAction(
				`File already exists: ${destPath}. Overwrite?`
			);
			if (shouldOverwrite === false) {
				console.log('Skipping‚Ä¶');
				continue;
			}

			// Remove
			fs.rmSync(destPath);
		}

		// Create a symlink
		fs.mkdirSync(path.dirname(destPath), { recursive: true });
		fs.symlinkSync(sourcePath, destPath);

		console.log('ü¶ê', destPath, '‚Üí', sourcePath);
	}
}

async function syncSpecials() {
	for (const { source, destination, copy } of SPECIALS) {
		// Check if the source exists
		if (fs.existsSync(source) === false) {
			continue;
		}

		// Check that we aren't overwriting anything
		if (fs.existsSync(destination)) {
			if (copy) {
				// Already identical to the source file?
				if (
					fs.lstatSync(destination).isFile() &&
					fs.readFileSync(source, 'utf8') ===
						fs.readFileSync(destination, 'utf8')
				) {
					continue;
				}
			} else {
				// Already a symlink to dotfiles?
				if (isSymlinkTo(destination, source)) {
					continue;
				}
			}

			// Should overwrite?
			const shouldOverwrite = await confirmAction(
				`File already exists: ${destination}. Overwrite?`
			);
			if (shouldOverwrite === false) {
				console.log('Skipping‚Ä¶');
				continue;
			}

			// Remove
			fs.rmSync(destination, { recursive: true, force: true });
		}

		// Create a folder if needed
		fs.mkdirSync(path.dirname(destination), { recursive: true });

		if (copy) {
			// Copy the file
			fs.copyFileSync(source, destination);
		} else {
			// Create a symlink
			fs.symlinkSync(source, destination);
		}

		console.log('ü¶ê', source, '‚Üí', destination);
	}
}

async function main() {
	console.log('Syncing dotfiles‚Ä¶');
	await syncDotfiles();
	await syncSpecials();
	console.log('Done.');
}

// --------- 8< --------- 8< --------- 8< ---------

main();
