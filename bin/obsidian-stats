#!/usr/bin/env node

// Generates Obsidian vault statistics:
// * Overall daily note heatmap
// * Weather history chart
//
// ---
// Author: Artem Sapegin, sapegin.me
// License: MIT
// https://github.com/sapegin/dotfiles

import fs from 'node:fs/promises';
import path from 'node:path';
import os from 'node:os';
import YAML from 'yaml';

const VAULT_DIR = path.join(os.homedir(), 'murder');
const LOG_DIR = path.join(VAULT_DIR, 'üìÜ Log');
const OUTPUT_FILE = path.join(os.homedir(), 'Documents/MurderStats.html');

const COLORS = {
	// Squirrelsong Light
	// Squirrelsong Deep Purple Dark
	brightPink: '#ca5a83',
};

const COLOR_SCALE = ['#f3e9fb', '#d5beed', '#ae95c7', '#9a7eb4', '#644e88'];

const MONTH_NAMES = [
	'Jan',
	'Feb',
	'Mar',
	'Apr',
	'May',
	'Jun',
	'Jul',
	'Aug',
	'Sep',
	'Oct',
	'Nov',
	'Dec',
];

const placeInfoCache = new Map();

async function getPlaceInfo(locationName) {
	if (placeInfoCache.has(locationName)) {
		return placeInfoCache.get(locationName);
	}

	const locationFilePath = path.join(
		VAULT_DIR,
		'üóÇÔ∏è References/Places',
		`${locationName}.md`
	);

	const defaultInfo = {
		locationType: 'other',
		icon: 'map-pin',
		color: 'silver',
	};

	try {
		const locationContent = await fs.readFile(locationFilePath, 'utf-8');
		const frontmatterMatch = locationContent.match(/^---\n([\s\S]*?)\n---/);

		if (frontmatterMatch) {
			const frontmatter = YAML.parse(frontmatterMatch[1]);
			const info = {
				locationType: locationContent.includes('dwellings')
					? 'home'
					: locationContent.includes('offices')
						? 'office'
						: 'other',
				icon: frontmatter?.icon || 'map-pin',
				color: frontmatter?.color || 'silver',
			};
			placeInfoCache.set(locationName, info);
			return info;
		}
	} catch (err) {
		// Location file not found or error reading
	}

	placeInfoCache.set(locationName, defaultInfo);
	return defaultInfo;
}

async function getDailyNotes() {
	const files = await Array.fromAsync(fs.glob(path.join(LOG_DIR, '**/*.md')));
	console.log(`Found ${files.length} daily notes`);

	const notes = new Map();
	const weatherStats = [];
	const postTimeStats = [];
	const locationStats = [];
	const notesWithCoords = [];
	let minDate = new Date();
	let maxDate = new Date(0);

	for (const file of files) {
		const basename = path.basename(file);
		const match = basename.match(/^(\d{4}-\d{2}-\d{2})_(\d{2})(\d{2})\.md$/);
		if (match) {
			const dateStr = match[1];
			const hours = parseInt(match[2], 10);
			const minutes = parseInt(match[3], 10);
			const timeInMinutes = hours * 60 + minutes;
			const count = notes.get(dateStr) ?? 0;
			notes.set(dateStr, count + 1);

			const date = new Date(dateStr);
			if (date < minDate) {
				minDate = date;
			}
			if (date > maxDate) {
				maxDate = date;
			}

			postTimeStats.push({ date: dateStr, time: timeInMinutes });

			// Read content and parse frontmatter
			const content = await fs.readFile(file, 'utf-8');
			const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
			if (frontmatterMatch) {
				try {
					const frontmatter = YAML.parse(frontmatterMatch[1]);

					// Extract weather
					if (frontmatter?.weather) {
						const weatherMatch =
							frontmatter.weather.match(/(-?\d+)¬∞C(?:, (.+))?/);
						if (weatherMatch) {
							const temp = parseInt(weatherMatch[1], 10);
							const condition = weatherMatch[2]
								? weatherMatch[2].trim().toLowerCase()
								: 'unknown';
							weatherStats.push({ date: dateStr, temp, condition });
						}
					}

					// Extract location and get place info
					let locationName = null;
					let placeInfo = null;
					if (frontmatter?.location) {
						const location = frontmatter.location;
						// Extract location name from wiki link format [[Location]] or plain text
						const wikiLinkMatch = location.match(/\[\[([^\]]+)\]\]/);
						locationName = wikiLinkMatch ? wikiLinkMatch[1] : location;
						placeInfo = await getPlaceInfo(locationName);
						locationStats.push({
							date: dateStr,
							locationType: placeInfo.locationType,
						});
					}

					// Extract coordinates
					if (frontmatter?.coordinates) {
						const [lat, lon] = frontmatter.coordinates
							.split(',')
							.map((c) => parseFloat(c.trim()));

						if (!isNaN(lat) && !isNaN(lon)) {
							let icon = 'map-pin';
							let color = 'silver';
							let placeName = 'Unknown location';

							if (placeInfo) {
								icon = placeInfo.icon;
								color = placeInfo.color;
							}

							if (locationName) {
								placeName = locationName;
							}

							notesWithCoords.push({
								lat,
								lon,
								placeName,
								icon,
								color,
							});
						}
					}
				} catch (error) {
					// Skip frontmatter parsing errors
				}
			}
		}
	}

	return {
		notes,
		weatherStats,
		postTimeStats,
		locationStats,
		notesWithCoords,
		minDate,
		maxDate,
	};
}

function getLevel(count, maxCount) {
	if (count === 0) {
		return 0;
	}
	if (maxCount === 0) {
		return 0;
	}
	const percentage = count / maxCount;
	if (percentage <= 0.25) {
		return 1;
	}
	if (percentage <= 0.5) {
		return 2;
	}
	if (percentage <= 0.75) {
		return 3;
	}
	return 4;
}

function formatDate(date) {
	return date.toISOString().split('T')[0];
}

const dateFormatter = new Intl.DateTimeFormat('en-US', {
	year: 'numeric',
	month: 'short',
	day: 'numeric',
});

function formatDateLong(date) {
	return dateFormatter.format(date);
}

function generateHeatmap(notes, year, maxCount) {
	const startDate = new Date(year, 0, 1);
	const firstDayOfWeek = startDate.getDay();

	const endDate = new Date(year, 11, 31);
	endDate.setDate(endDate.getDate() + (6 - endDate.getDay()));

	const totalDays = (endDate - startDate) / (1000 * 60 * 60 * 24) + 1;
	const totalWeeks = Math.ceil((totalDays + firstDayOfWeek) / 7);

	let html = '<table class="heatmap">\n';

	html += '<thead><tr><th></th>';
	let currentMonth = -1;
	let monthSpan = 0;
	const monthCells = [];
	for (let w = 0; w < totalWeeks; w++) {
		const weekDate = new Date(startDate);
		weekDate.setDate(weekDate.getDate() + w * 7 - firstDayOfWeek);
		const month = weekDate.getMonth();
		const weekYear = weekDate.getFullYear();
		if (weekYear === year && month !== currentMonth) {
			if (currentMonth !== -1) {
				monthCells.push({ month: currentMonth, span: monthSpan });
			}
			currentMonth = month;
			monthSpan = 1;
		} else if (weekYear === year) {
			monthSpan++;
		}
	}
	if (currentMonth !== -1) {
		monthCells.push({ month: currentMonth, span: monthSpan });
	}
	for (const { month, span } of monthCells) {
		html += `<th colspan="${span}">${MONTH_NAMES[month]}</th>`;
	}
	html += '</tr></thead>\n';

	html += '<tbody>\n';

	for (let d = 0; d < 7; d++) {
		html += '<tr>';
		const label = d === 1 ? 'Mon' : d === 3 ? 'Wed' : d === 5 ? 'Fri' : '';
		html += `<td class="day-label">${label}</td>`;

		for (let w = 0; w < totalWeeks; w++) {
			const date = new Date(startDate);
			date.setDate(date.getDate() + w * 7 + d - firstDayOfWeek);
			const dateStr = formatDate(date);
			const dateYear = date.getFullYear();

			if (dateYear !== year) {
				html += '<td></td>';
			} else {
				const count = notes.get(dateStr) || 0;
				const level = getLevel(count, maxCount);
				html += `<td class="level-${level}" title="${count} notes on ${formatDateLong(date)}"></td>`;
			}
		}
		html += '</tr>\n';
	}

	html += '</tbody></table>';
	return html;
}

function processWeatherStats(weatherStats, minDate, maxDate) {
	const months = new Map(); // "YYYY-MM" -> { tempSum, tempCount, sunny, partly, cloudy }

	for (const { date, temp, condition } of weatherStats) {
		const month = date.substring(0, 7);
		if (!months.has(month)) {
			months.set(month, {
				tempSum: 0,
				tempCount: 0,
				sunny: 0,
				partly: 0,
				cloudy: 0,
			});
		}
		const stats = months.get(month);
		stats.tempSum += temp;
		stats.tempCount++;

		if (['sunny', 'clear'].includes(condition)) {
			stats.sunny++;
		} else if (
			['mainly sunny', 'mainly clear', 'partly cloudy'].includes(condition)
		) {
			stats.partly++;
		} else if (['overcast', 'cloudy'].includes(condition)) {
			stats.cloudy++;
		}
	}

	// Fill gaps between minDate and maxDate
	const allMonths = [];
	let current = new Date(minDate.getFullYear(), minDate.getMonth(), 1);
	const end = new Date(maxDate.getFullYear(), maxDate.getMonth(), 1);

	while (current <= end) {
		const monthKey = `${current.getFullYear()}-${String(current.getMonth() + 1).padStart(2, '0')}`;
		allMonths.push(monthKey);
		current.setMonth(current.getMonth() + 1);
	}

	const labels = [];
	const sunny = [];
	const partly = [];
	const cloudy = [];
	let minTemp = Infinity;

	for (const month of allMonths) {
		const stats = months.get(month);
		const date = new Date(`${month}-02`);
		labels.push(
			date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })
		);

		if (stats && stats.tempCount > 0) {
			const total = stats.sunny + stats.partly + stats.cloudy;
			sunny.push(total > 0 ? ((stats.sunny / total) * 100).toFixed(1) : 0);
			partly.push(total > 0 ? ((stats.partly / total) * 100).toFixed(1) : 0);
			cloudy.push(total > 0 ? ((stats.cloudy / total) * 100).toFixed(1) : 0);
		} else {
			sunny.push(0);
			partly.push(0);
			cloudy.push(0);
		}
	}

	// Process individual temperature points - map to month labels
	const tempPoints = [];
	for (const { date, temp } of weatherStats) {
		const month = date.substring(0, 7);
		const monthDate = new Date(`${month}-02`);
		const monthLabel = monthDate.toLocaleDateString('en-US', {
			month: 'short',
			year: 'numeric',
		});
		tempPoints.push({ x: monthLabel, y: temp });
		if (temp < minTemp) minTemp = temp;
	}

	return { labels, tempPoints, sunny, partly, cloudy, minTemp };
}

function processPostTimeStats(postTimeStats, minDate, maxDate) {
	const allMonths = [];
	let current = new Date(minDate.getFullYear(), minDate.getMonth(), 1);
	const end = new Date(maxDate.getFullYear(), maxDate.getMonth(), 1);

	while (current <= end) {
		const monthKey = `${current.getFullYear()}-${String(current.getMonth() + 1).padStart(2, '0')}`;
		allMonths.push(monthKey);
		current.setMonth(current.getMonth() + 1);
	}

	const labels = [];
	for (const month of allMonths) {
		const date = new Date(`${month}-02`);
		labels.push(
			date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })
		);
	}

	const timePoints = [];

	for (const { date, time } of postTimeStats) {
		const month = date.substring(0, 7);
		const monthDate = new Date(`${month}-02`);
		const monthLabel = monthDate.toLocaleDateString('en-US', {
			month: 'short',
			year: 'numeric',
		});
		const hours = Math.floor(time / 60);
		const minutes = time % 60;
		let timeDecimal = hours + minutes / 60;
		// Adjust times before 3:30am to next day (24+ hours)
		if (timeDecimal < 3.5) {
			timeDecimal += 24;
		}
		timePoints.push({ x: monthLabel, y: timeDecimal });
	}

	return { labels, timePoints };
}

function processLocationStats(locationStats, minDate, maxDate) {
	const months = new Map();

	for (const { date, locationType } of locationStats) {
		const month = date.substring(0, 7);
		if (!months.has(month)) {
			months.set(month, { home: 0, office: 0, other: 0, total: 0 });
		}
		const stats = months.get(month);
		stats.total++;
		if (locationType === 'home') {
			stats.home++;
		} else if (locationType === 'office') {
			stats.office++;
		} else {
			stats.other++;
		}
	}

	const allMonths = [];
	let current = new Date(minDate.getFullYear(), minDate.getMonth(), 1);
	const end = new Date(maxDate.getFullYear(), maxDate.getMonth(), 1);

	while (current <= end) {
		const monthKey = `${current.getFullYear()}-${String(current.getMonth() + 1).padStart(2, '0')}`;
		allMonths.push(monthKey);
		current.setMonth(current.getMonth() + 1);
	}

	const labels = [];
	const homePercentages = [];
	const officePercentages = [];
	const otherPercentages = [];

	for (const month of allMonths) {
		const stats = months.get(month);
		const date = new Date(`${month}-02`);
		labels.push(
			date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })
		);

		if (stats && stats.total > 0) {
			homePercentages.push(((stats.home / stats.total) * 100).toFixed(1));
			officePercentages.push(((stats.office / stats.total) * 100).toFixed(1));
			otherPercentages.push(((stats.other / stats.total) * 100).toFixed(1));
		} else {
			homePercentages.push(0);
			officePercentages.push(0);
			otherPercentages.push(0);
		}
	}

	return { labels, homePercentages, officePercentages, otherPercentages };
}

function generateWeatherChart(data) {
	const minTemp = Math.floor(data.minTemp);
	return `
<div style="position: relative; height: 400px; width: 100%; margin-bottom: 2rem;">
	<canvas id="weatherChart"></canvas>
</div>
<script>
	const ctx = document.getElementById('weatherChart');
	new Chart(ctx, {
		type: 'bar',
		data: {
			labels: ${JSON.stringify(data.labels)},
			datasets: [
				{
					label: 'Sunny',
					data: ${JSON.stringify(data.sunny)},
					backgroundColor: '${COLOR_SCALE[4]}',
					stack: 'Stack 0',
					yAxisID: 'y',
					order: 2
				},
				{
					label: 'Partly cloudy',
					data: ${JSON.stringify(data.partly)},
					backgroundColor: '${COLOR_SCALE[2]}',
					stack: 'Stack 0',
					yAxisID: 'y',
					order: 2
				},
				{
					label: 'Cloudy',
					data: ${JSON.stringify(data.cloudy)},
					backgroundColor: '${COLOR_SCALE[0]}',
					stack: 'Stack 0',
					yAxisID: 'y',
					order: 2
				},
				{
					label: 'Temperature',
					data: ${JSON.stringify(data.tempPoints)},
					type: 'scatter',
					borderColor: 'transparent',
					backgroundColor: '${COLORS.brightPink}',
					pointBackgroundColor: '${COLORS.brightPink}',
					pointBorderColor: '${COLORS.brightPink}',
					pointRadius: 2,
					yAxisID: 'y1',
					order: 1
				}
			]
		},
		options: {
			responsive: true,
			maintainAspectRatio: false,
			plugins: {
				tooltip: {
					enabled: false
				}
			},
			scales: {
				x: {
					stacked: true,
					type: 'category'
				},
				y: {
					type: 'linear',
					display: true,
					position: 'left',
					stacked: true,
					max: 100,
					ticks: {
						display: false
					},
					title: {
						display: false,
						text: 'Conditions'
					},
				},
				y1: {
					type: 'linear',
					display: true,
					position: 'right',
					min: ${minTemp},
					grid: {
						drawOnChartArea: false,
					},
					title: {
						display: false,
						text: 'Temperature'
					},
          ticks: {
						callback: function(value) {
							return String(value).replace('-', '‚àí') + '¬∞C';
						}
					}
				},
			}
		}
	});
</script>`;
}

function generatePostTimeChart(data) {
	return `
<div style="position: relative; height: 400px; width: 100%; margin-bottom: 2rem;">
	<canvas id="postTimeChart"></canvas>
</div>
<script>
	const ctxTime = document.getElementById('postTimeChart');
	new Chart(ctxTime, {
		type: 'scatter',
		data: {
			labels: ${JSON.stringify(data.labels)},
			datasets: [
				{
					label: 'Post time',
					data: ${JSON.stringify(data.timePoints)},
					type: 'scatter',
					borderColor: 'transparent',
					backgroundColor: '${COLORS.brightPink}',
					pointBackgroundColor: '${COLORS.brightPink}',
					pointBorderColor: '${COLORS.brightPink}',
					pointRadius: 2
				}
			]
		},
		options: {
			responsive: true,
			maintainAspectRatio: false,
			plugins: {
				legend: {
					display: false
				},
				tooltip: {
					enabled: true,
					callbacks: {
						title: function(context) {
							return context[0].label;
						},
						label: function(context) {
							const value = context.parsed.y;
							const adjustedValue = value >= 24 ? value - 24 : value;
							const hours = Math.floor(adjustedValue);
							const minutes = Math.round((adjustedValue - hours) * 60);
							return hours + ':' + String(minutes).padStart(2, '0');
						}
					}
				}
			},
			scales: {
				x: {
					type: 'category',
					title: {
						display: false
					}
				},
				y: {
					type: 'linear',
					display: true,
					position: 'right',
					min: 3.5,
					max: 27.5,
					reverse: true,
					title: {
						display: false,
						text: 'Time (hours)'
					},
					ticks: {
						callback: function(value) {
							// TODO: This is the same as above, we should extract it
							const adjustedValue = value >= 24 ? value - 24 : value;
							const hours = Math.floor(adjustedValue);
							const minutes = Math.round((adjustedValue - hours) * 60);
							return hours + ':' + String(minutes).padStart(2, '0');
						}
					}
				}
			}
		}
	});
</script>`;
}

function generateLocationChart(data) {
	return `
<div style="position: relative; height: 400px; width: 100%; margin-bottom: 2rem;">
	<canvas id="locationChart"></canvas>
</div>
<script>
	const ctxLocation = document.getElementById('locationChart');
	new Chart(ctxLocation, {
		type: 'bar',
		data: {
			labels: ${JSON.stringify(data.labels)},
			datasets: [
				{
					label: 'Home',
					data: ${JSON.stringify(data.homePercentages)},
					backgroundColor: '${COLOR_SCALE[4]}',
					stack: 'Stack 0'
				},
				{
					label: 'Office',
					data: ${JSON.stringify(data.officePercentages)},
					backgroundColor: '${COLOR_SCALE[2]}',
					stack: 'Stack 0'
				},
				{
					label: 'Other',
					data: ${JSON.stringify(data.otherPercentages)},
					backgroundColor: '${COLOR_SCALE[0]}',
					stack: 'Stack 0'
				}
			]
		},
		options: {
			responsive: true,
			maintainAspectRatio: false,
			plugins: {
				legend: {
					display: true
				},
				tooltip: {
					enabled: false
				}
			},
			scales: {
				x: {
					type: 'category',
					stacked: true
				},
				y: {
					type: 'linear',
					display: true,
					position: 'left',
					stacked: true,
					min: 0,
					max: 100,
					ticks: {
						display: false
					},
					title: {
						display: false
					}
				}
			}
		}
	});
</script>`;
}

function generateLocationMap(notes) {
	// Group notes by coordinates for display
	const locationMap = new Map();
	for (const note of notes) {
		const key = `${note.lat},${note.lon}`;
		if (!locationMap.has(key)) {
			locationMap.set(key, {
				lat: note.lat,
				lon: note.lon,
				placeName: note.placeName,
				icon: note.icon,
				color: note.color,
				count: 1,
			});
		} else {
			locationMap.get(key).count++;
		}
	}

	const groupedLocations = Array.from(locationMap.values());

	return `
<div id="map" style="height: 600px; width: 100%; margin-bottom: 2rem;"></div>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
<script src="https://unpkg.com/lucide@latest"></script>
<style>
	.custom-marker {
		display: flex;
		align-items: center;
		justify-content: center;
		width: 32px;
		height: 32px;
		background: white;
		border-radius: 50% 50% 50% 0;
		box-shadow: 0 2px 4px rgba(0,0,0,0.3);
		transform: rotate(-45deg);
		border: 2px solid white;
	}
	.custom-marker svg {
		transform: rotate(45deg);
		width: 20px;
		height: 20px;
	}
</style>
<script>
	const allNotes = ${JSON.stringify(notes)};
	const groupedLocations = ${JSON.stringify(groupedLocations)};

	// Create a map to lookup location info by coordinates
	const locationInfo = new Map();
	for (const loc of groupedLocations) {
		locationInfo.set(\`\${loc.lat},\${loc.lon}\`, loc);
	}

	const map = L.map('map').setView([${notes.length > 0 ? `${notes[0].lat}, ${notes[0].lon}` : '0, 0'}], ${notes.length > 0 ? '10' : '2'});

	L.tileLayer('http://services.arcgisonline.com/arcgis/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
		maxZoom: 19
	}).addTo(map);

	const markers = L.markerClusterGroup({
		maxClusterRadius: 50,
		spiderfyOnMaxZoom: true,
		showCoverageOnHover: false,
		zoomToBoundsOnClick: true
	});

	// Convert kebab-case to PascalCase for Lucide icon names
	function toPascalCase(str) {
		return str.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join('');
	}

	// Get Lucide icon SVG
	function getIconSvg(iconName) {
		try {
			const pascalName = toPascalCase(iconName);
			const iconFunc = lucide[pascalName];
			if (!iconFunc) {
				console.warn('Icon not found:', iconName, pascalName);
				return '';
			}

			// Create a temporary element to render the icon
			const temp = document.createElement('div');
			temp.innerHTML = '<i data-lucide="' + iconName + '"></i>';
			document.body.appendChild(temp);
			lucide.createIcons({ icons: { [pascalName]: iconFunc }, nameAttr: 'data-lucide' });
			const svg = temp.querySelector('svg');
			const svgString = svg ? svg.outerHTML : '';
			document.body.removeChild(temp);
			return svgString;
		} catch (e) {
			console.error('Error getting icon:', iconName, e);
			return '';
		}
	}

	// Add all notes as individual markers with shared popup content per location
	for (const note of allNotes) {
		const key = \`\${note.lat},\${note.lon}\`;
		const locInfo = locationInfo.get(key);

		let iconHtml;
		if (note.icon === 'map-pin') {
			// No icon, just colored background
			iconHtml = \`<div class="custom-marker" style="background-color: \${note.color};"></div>\`;
		} else {
			const iconSvg = getIconSvg(note.icon);
			iconHtml = \`<div class="custom-marker" style="background-color: \${note.color};">\${iconSvg}</div>\`;
		}

		const customIcon = L.divIcon({
			html: iconHtml,
			className: '',
			iconSize: [32, 32],
			iconAnchor: [16, 32],
			popupAnchor: [0, -32]
		});

		const marker = L.marker([note.lat, note.lon], { icon: customIcon });

		// All markers at the same location share the same popup content
		if (locInfo) {
			marker.bindPopup(\`<strong>\${locInfo.placeName}</strong><br>\${locInfo.count} note\${locInfo.count !== 1 ? 's' : ''}\`);
		}

		markers.addLayer(marker);
	}

	map.addLayer(markers);

	if (allNotes.length > 1) {
		const bounds = L.latLngBounds(allNotes.map(n => [n.lat, n.lon]));
		map.fitBounds(bounds, { padding: [50, 50] });
	}
</script>`;
}

async function main() {
	console.log('Scanning daily notes...');
	const {
		notes,
		weatherStats,
		postTimeStats,
		locationStats,
		notesWithCoords,
		minDate,
		maxDate,
	} = await getDailyNotes();
	console.log(`Found ${notes.size} days with notes`);
	console.log(`Found ${notesWithCoords.length} notes with coordinates`);
	console.log(`Range: ${formatDate(minDate)} to ${formatDate(maxDate)}`);

	let maxCount = 0;
	for (const count of notes.values()) {
		if (count > maxCount) maxCount = count;
	}

	const minYear = minDate.getFullYear();
	const maxYear = maxDate.getFullYear();

	const heatmaps = [];
	for (let year = maxYear; year >= minYear; year--) {
		let yearCount = 0;
		for (const [dateStr, count] of notes) {
			if (dateStr.startsWith(`${year}-`)) {
				yearCount += count;
			}
		}
		heatmaps.push(
			`<h3>${year} <span class="count">(${yearCount} notes)</span></h3>\n${generateHeatmap(notes, year, maxCount)}`
		);
	}

	let totalNotes = 0;
	for (const count of notes.values()) {
		totalNotes += count;
	}

	const weatherData = processWeatherStats(weatherStats, minDate, maxDate);
	const weatherChart = generateWeatherChart(weatherData);

	const postTimeData = processPostTimeStats(postTimeStats, minDate, maxDate);
	const postTimeChart = generatePostTimeChart(postTimeData);

	const locationData = processLocationStats(locationStats, minDate, maxDate);
	const locationChart = generateLocationChart(locationData);

	const locationMap = generateLocationMap(notesWithCoords);

	const html = `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Murder of crows vault stats</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
	body { font-family: -apple-system, sans-serif; padding: 1rem; color: #4c4b4e; background-color: #fff; max-width: 1200px; margin: 0 auto; }
	h1 { margin-top: 0; margin-bottom: .5rem; }
	.summary { font-size: 1rem; color: #8c8792; margin-bottom: 1rem; }
	h2 { margin-top: 2rem; margin-bottom: .5rem; }
	.count { font-size: 1rem; font-weight: normal; color: #8c8792; }
	.heatmap { border-collapse: separate; border-spacing: 3px; }
	.heatmap th { font-size: .7rem; color: #8c8792; font-weight: normal; text-align: left; width: 12px; }
	.heatmap td { width: .75rem; height: .75rem; border-radius: 2px; }
	.heatmap .day-label {  font-size: .7rem; color: #8c8792;  vertical-align: middle; text-align: right; padding-right: .2rem; }
	.level-0 { background-color: ${COLOR_SCALE[0]}; }
	.level-1 { background-color: ${COLOR_SCALE[1]}; }
	.level-2 { background-color: ${COLOR_SCALE[2]}; }
	.level-3 { background-color: ${COLOR_SCALE[3]}; }
	.level-4 { background-color: ${COLOR_SCALE[4]}; }
	#map { border-radius: 4px; border: 1px solid #e0e0e0; }
</style>
</head>
<body>
	<h1>Murder of crows vault stats</h1>
	<p class="summary">${totalNotes} notes from ${formatDateLong(minDate)} to ${formatDateLong(maxDate)}</p>

	<h2>Times of day</h2>
  ${postTimeChart}

	<h2>Weather conditions and temperature</h2>
  ${weatherChart}

  <h2>Locations</h2>
  ${locationChart}

	<h2>Map of all notes</h2>
	${locationMap}

  <h2>Notes over the years</h2>
	${heatmaps.join('\n')}
</body>
</html>`;

	await fs.writeFile(OUTPUT_FILE, html);
	console.log(`Stats generated at: ${OUTPUT_FILE}`);
}

main().catch(console.error);
