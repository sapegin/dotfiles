#!/usr/bin/env node

// Generates Obsidian vault statistics:
// * Overall daily note heatmap
// * Weather history chart
//
// ---
// Author: Artem Sapegin, sapegin.me
// License: MIT
// https://github.com/sapegin/dotfiles

import fs from 'node:fs/promises';
import path from 'node:path';
import os from 'node:os';

const VAULT_DIR = path.join(os.homedir(), 'murder');
const LOG_DIR = path.join(VAULT_DIR, 'ðŸ“† Log');
const OUTPUT_FILE = path.join(os.homedir(), 'Documents/MurderStats.html');

const COLORS = {
	// Squirrelsong Light
	// Squirrelsong Deep Purple Dark
	brightPink: '#ca5a83',
};

const MONTH_NAMES = [
	'Jan',
	'Feb',
	'Mar',
	'Apr',
	'May',
	'Jun',
	'Jul',
	'Aug',
	'Sep',
	'Oct',
	'Nov',
	'Dec',
];

async function getDailyNotes() {
	const files = await Array.fromAsync(fs.glob(path.join(LOG_DIR, '**/*.md')));

	const notes = new Map();
	const weatherStats = [];
	const postTimeStats = [];
	let minDate = new Date();
	let maxDate = new Date(0);

	for (const file of files) {
		const basename = path.basename(file);
		const match = basename.match(/^(\d{4}-\d{2}-\d{2})_(\d{2})(\d{2})\.md$/);
		if (match) {
			const dateStr = match[1];
			const hours = parseInt(match[2], 10);
			const minutes = parseInt(match[3], 10);
			const timeInMinutes = hours * 60 + minutes;
			const count = notes.get(dateStr) ?? 0;
			notes.set(dateStr, count + 1);

			const date = new Date(dateStr);
			if (date < minDate) {
				minDate = date;
			}
			if (date > maxDate) {
				maxDate = date;
			}

			postTimeStats.push({ date: dateStr, time: timeInMinutes });

			// Read content for weather
			const content = await fs.readFile(file, 'utf-8');
			const weatherMatch = content.match(/^weather: (-?\d+)Â°C(?:, (.+))?$/m);
			if (weatherMatch) {
				const temp = parseInt(weatherMatch[1], 10);
				const condition = weatherMatch[2]
					? weatherMatch[2].trim().toLowerCase()
					: 'unknown';
				weatherStats.push({ date: dateStr, temp, condition });
			}
		}
	}

	return { notes, weatherStats, postTimeStats, minDate, maxDate };
}

function getLevel(count, maxCount) {
	if (count === 0) {
		return 0;
	}
	if (maxCount === 0) {
		return 0;
	}
	const percentage = count / maxCount;
	if (percentage <= 0.25) {
		return 1;
	}
	if (percentage <= 0.5) {
		return 2;
	}
	if (percentage <= 0.75) {
		return 3;
	}
	return 4;
}

function formatDate(date) {
	return date.toISOString().split('T')[0];
}

const dateFormatter = new Intl.DateTimeFormat('en-US', {
	year: 'numeric',
	month: 'short',
	day: 'numeric',
});

function formatDateLong(date) {
	return dateFormatter.format(date);
}

function generateHeatmap(notes, year, maxCount) {
	const startDate = new Date(year, 0, 1);
	const firstDayOfWeek = startDate.getDay();

	const endDate = new Date(year, 11, 31);
	endDate.setDate(endDate.getDate() + (6 - endDate.getDay()));

	const totalDays = (endDate - startDate) / (1000 * 60 * 60 * 24) + 1;
	const totalWeeks = Math.ceil((totalDays + firstDayOfWeek) / 7);

	let html = '<table class="heatmap">\n';

	html += '<thead><tr><th></th>';
	let currentMonth = -1;
	let monthSpan = 0;
	const monthCells = [];
	for (let w = 0; w < totalWeeks; w++) {
		const weekDate = new Date(startDate);
		weekDate.setDate(weekDate.getDate() + w * 7 - firstDayOfWeek);
		const month = weekDate.getMonth();
		const weekYear = weekDate.getFullYear();
		if (weekYear === year && month !== currentMonth) {
			if (currentMonth !== -1) {
				monthCells.push({ month: currentMonth, span: monthSpan });
			}
			currentMonth = month;
			monthSpan = 1;
		} else if (weekYear === year) {
			monthSpan++;
		}
	}
	if (currentMonth !== -1) {
		monthCells.push({ month: currentMonth, span: monthSpan });
	}
	for (const { month, span } of monthCells) {
		html += `<th colspan="${span}">${MONTH_NAMES[month]}</th>`;
	}
	html += '</tr></thead>\n';

	html += '<tbody>\n';

	for (let d = 0; d < 7; d++) {
		html += '<tr>';
		const label = d === 1 ? 'Mon' : d === 3 ? 'Wed' : d === 5 ? 'Fri' : '';
		html += `<td class="day-label">${label}</td>`;

		for (let w = 0; w < totalWeeks; w++) {
			const date = new Date(startDate);
			date.setDate(date.getDate() + w * 7 + d - firstDayOfWeek);
			const dateStr = formatDate(date);
			const dateYear = date.getFullYear();

			if (dateYear !== year) {
				html += '<td></td>';
			} else {
				const count = notes.get(dateStr) || 0;
				const level = getLevel(count, maxCount);
				html += `<td class="level-${level}" title="${count} notes on ${formatDateLong(date)}"></td>`;
			}
		}
		html += '</tr>\n';
	}

	html += '</tbody></table>';
	return html;
}

function processWeatherStats(weatherStats, minDate, maxDate) {
	const months = new Map(); // "YYYY-MM" -> { tempSum, tempCount, sunny, partly, cloudy }

	for (const { date, temp, condition } of weatherStats) {
		const month = date.substring(0, 7);
		if (!months.has(month)) {
			months.set(month, {
				tempSum: 0,
				tempCount: 0,
				sunny: 0,
				partly: 0,
				cloudy: 0,
			});
		}
		const stats = months.get(month);
		stats.tempSum += temp;
		stats.tempCount++;

		if (['sunny', 'clear'].includes(condition)) {
			stats.sunny++;
		} else if (
			['mainly sunny', 'mainly clear', 'partly cloudy'].includes(condition)
		) {
			stats.partly++;
		} else if (['overcast', 'cloudy'].includes(condition)) {
			stats.cloudy++;
		}
	}

	// Fill gaps between minDate and maxDate
	const allMonths = [];
	let current = new Date(minDate.getFullYear(), minDate.getMonth(), 1);
	const end = new Date(maxDate.getFullYear(), maxDate.getMonth(), 1);

	while (current <= end) {
		const monthKey = `${current.getFullYear()}-${String(current.getMonth() + 1).padStart(2, '0')}`;
		allMonths.push(monthKey);
		current.setMonth(current.getMonth() + 1);
	}

	const labels = [];
	const sunny = [];
	const partly = [];
	const cloudy = [];
	let minTemp = Infinity;

	for (const month of allMonths) {
		const stats = months.get(month);
		const date = new Date(`${month}-02`);
		labels.push(
			date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })
		);

		if (stats && stats.tempCount > 0) {
			const total = stats.sunny + stats.partly + stats.cloudy;
			sunny.push(total > 0 ? ((stats.sunny / total) * 100).toFixed(1) : 0);
			partly.push(total > 0 ? ((stats.partly / total) * 100).toFixed(1) : 0);
			cloudy.push(total > 0 ? ((stats.cloudy / total) * 100).toFixed(1) : 0);
		} else {
			sunny.push(0);
			partly.push(0);
			cloudy.push(0);
		}
	}

	// Process individual temperature points - map to month labels
	const tempPoints = [];
	for (const { date, temp } of weatherStats) {
		const month = date.substring(0, 7);
		const monthDate = new Date(`${month}-02`);
		const monthLabel = monthDate.toLocaleDateString('en-US', {
			month: 'short',
			year: 'numeric',
		});
		tempPoints.push({ x: monthLabel, y: temp });
		if (temp < minTemp) minTemp = temp;
	}

	return { labels, tempPoints, sunny, partly, cloudy, minTemp };
}

function processPostTimeStats(postTimeStats, minDate, maxDate) {
	const allMonths = [];
	let current = new Date(minDate.getFullYear(), minDate.getMonth(), 1);
	const end = new Date(maxDate.getFullYear(), maxDate.getMonth(), 1);

	while (current <= end) {
		const monthKey = `${current.getFullYear()}-${String(current.getMonth() + 1).padStart(2, '0')}`;
		allMonths.push(monthKey);
		current.setMonth(current.getMonth() + 1);
	}

	const labels = [];
	for (const month of allMonths) {
		const date = new Date(`${month}-02`);
		labels.push(
			date.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })
		);
	}

	const timePoints = [];

	for (const { date, time } of postTimeStats) {
		const month = date.substring(0, 7);
		const monthDate = new Date(`${month}-02`);
		const monthLabel = monthDate.toLocaleDateString('en-US', {
			month: 'short',
			year: 'numeric',
		});
		const hours = Math.floor(time / 60);
		const minutes = time % 60;
		let timeDecimal = hours + minutes / 60;
		// Adjust times before 3:30am to next day (24+ hours)
		if (timeDecimal < 3.5) {
			timeDecimal += 24;
		}
		timePoints.push({ x: monthLabel, y: timeDecimal });
	}

	return { labels, timePoints };
}

function generateWeatherChart(data) {
	const minTemp = Math.floor(data.minTemp);
	return `
<div style="position: relative; height: 400px; width: 100%; margin-bottom: 2rem;">
	<canvas id="weatherChart"></canvas>
</div>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
	const ctx = document.getElementById('weatherChart');
	new Chart(ctx, {
		type: 'bar',
		data: {
			labels: ${JSON.stringify(data.labels)},
			datasets: [
				{
					label: 'Sunny',
					data: ${JSON.stringify(data.sunny)},
					backgroundColor: '#e4c158',
					stack: 'Stack 0',
					yAxisID: 'y',
					order: 2
				},
				{
					label: 'Partly cloudy',
					data: ${JSON.stringify(data.partly)},
					backgroundColor: '#f3e2d3',
					stack: 'Stack 0',
					yAxisID: 'y',
					order: 2
				},
				{
					label: 'Cloudy',
					data: ${JSON.stringify(data.cloudy)},
					backgroundColor: '#9c96a2',
					stack: 'Stack 0',
					yAxisID: 'y',
					order: 2
				},
				{
					label: 'Temperature (Â°C)',
					data: ${JSON.stringify(data.tempPoints)},
					type: 'scatter',
					borderColor: 'transparent',
					backgroundColor: '${COLORS.brightPink}',
					pointBackgroundColor: '${COLORS.brightPink}',
					pointBorderColor: '${COLORS.brightPink}',
					pointRadius: 2,
					yAxisID: 'y1',
					order: 1
				}
			]
		},
		options: {
			responsive: true,
			maintainAspectRatio: false,
			plugins: {
				legend: {
					reverse: true
				},
				tooltip: {
					enabled: false
				}
			},
			scales: {
				x: {
					stacked: true,
					type: 'category'
				},
				y: {
					type: 'linear',
					display: true,
					position: 'left',
					stacked: true,
					max: 100,
					title: {
						display: false,
						text: 'Weather (%)'
					}
				},
				y1: {
					type: 'linear',
					display: true,
					position: 'right',
					min: ${minTemp},
					grid: {
						drawOnChartArea: false,
					},
					title: {
						display: true,
						text: 'Temperature (Â°C)'
					}
				},
			}
		}
	});
</script>`;
}

function generatePostTimeChart(data) {
	return `
<div style="position: relative; height: 400px; width: 100%; margin-bottom: 2rem;">
	<canvas id="postTimeChart"></canvas>
</div>
<script>
	const ctxTime = document.getElementById('postTimeChart');
	new Chart(ctxTime, {
		type: 'scatter',
		data: {
			labels: ${JSON.stringify(data.labels)},
			datasets: [
				{
					label: 'Post time',
					data: ${JSON.stringify(data.timePoints)},
					type: 'scatter',
					borderColor: 'transparent',
					backgroundColor: '${COLORS.brightPink}',
					pointBackgroundColor: '${COLORS.brightPink}',
					pointBorderColor: '${COLORS.brightPink}',
					pointRadius: 2
				}
			]
		},
		options: {
			responsive: true,
			maintainAspectRatio: false,
			plugins: {
				legend: {
					display: false
				},
				tooltip: {
					enabled: true,
					callbacks: {
						title: function(context) {
							return context[0].label;
						},
						label: function(context) {
							const value = context.parsed.y;
							const adjustedValue = value >= 24 ? value - 24 : value;
							const hours = Math.floor(adjustedValue);
							const minutes = Math.round((adjustedValue - hours) * 60);
							return hours + ':' + String(minutes).padStart(2, '0');
						}
					}
				}
			},
			scales: {
				x: {
					type: 'category',
					title: {
						display: false
					}
				},
				y: {
					type: 'linear',
					display: true,
					position: 'left',
					min: 3.5,
					max: 27.5,
					reverse: true,
					title: {
						display: true,
						text: 'Time (hours)'
					},
					ticks: {
						callback: function(value) {
							const adjustedValue = value >= 24 ? value - 24 : value;
							const hours = Math.floor(adjustedValue);
							const minutes = Math.round((adjustedValue - hours) * 60);
							return hours + ':' + String(minutes).padStart(2, '0');
						}
					}
				}
			}
		}
	});
</script>`;
}

async function main() {
	console.log('Scanning daily notes...');
	const { notes, weatherStats, postTimeStats, minDate, maxDate } =
		await getDailyNotes();
	console.log(`Found ${notes.size} days with notes.`);
	console.log(`Range: ${formatDate(minDate)} to ${formatDate(maxDate)}`);

	let maxCount = 0;
	for (const count of notes.values()) {
		if (count > maxCount) maxCount = count;
	}

	const minYear = minDate.getFullYear();
	const maxYear = maxDate.getFullYear();

	const heatmaps = [];
	for (let year = maxYear; year >= minYear; year--) {
		let yearCount = 0;
		for (const [dateStr, count] of notes) {
			if (dateStr.startsWith(`${year}-`)) {
				yearCount += count;
			}
		}
		heatmaps.push(
			`<h3>${year} <span class="count">(${yearCount} notes)</span></h3>\n${generateHeatmap(notes, year, maxCount)}`
		);
	}

	let totalNotes = 0;
	for (const count of notes.values()) {
		totalNotes += count;
	}

	const weatherData = processWeatherStats(weatherStats, minDate, maxDate);
	const weatherChart = generateWeatherChart(weatherData);

	const postTimeData = processPostTimeStats(postTimeStats, minDate, maxDate);
	const postTimeChart = generatePostTimeChart(postTimeData);

	const html = `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Murder of crows vault stats</title>
<style>
	body { font-family: -apple-system, sans-serif; padding: 1rem; color: #4c4b4e; background-color: #fff; max-width: 1200px; margin: 0 auto; }
	h1 { margin-top: 0; margin-bottom: .5rem; }
	.summary { font-size: 1rem; color: #8c8792; margin-bottom: 1rem; }
	h2 { margin-top: 2rem; margin-bottom: .5rem; }
	.count { font-size: 1rem; font-weight: normal; color: #8c8792; }
	.heatmap { border-collapse: separate; border-spacing: 3px; }
	.heatmap th { font-size: .7rem; color: #8c8792; font-weight: normal; text-align: left; width: 12px; }
	.heatmap td { width: .75rem; height: .75rem; border-radius: 2px; }
	.heatmap .day-label {  font-size: .7rem; color: #8c8792;  vertical-align: middle; text-align: right; padding-right: .2rem; }
	.level-0 { background-color: #e8e5eb; }
	.level-1 { background-color: #d5beed; }
	.level-2 { background-color: #ae95c7; }
	.level-3 { background-color: #9a7eb4; }
	.level-4 { background-color: #644e88; }
</style>
</head>
<body>
	<h1>Murder of crows vault stats</h1>
	<p class="summary">${totalNotes} notes from ${formatDateLong(minDate)} to ${formatDateLong(maxDate)}</p>
	<h2>Weather over the years</h2>
  ${weatherChart}

  <h2>Journaling times over the years</h2>
  ${postTimeChart}

  <h2>Notes over the years</h2>
	${heatmaps.join('\n')}
</body>
</html>`;

	await fs.writeFile(OUTPUT_FILE, html);
	console.log(`Stats generated at: ${OUTPUT_FILE}`);
}

main().catch(console.error);
