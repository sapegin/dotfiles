#!/usr/bin/env node

// Optimizes images in Obsidian vault: removes unused images, converts large
// PNG files to AVIF, and downsizes oversized images. Also cleans up journal
// entries frontmatter.
//
// ---
// Author: Artem Sapegin, sapegin.me
// License: MIT
// https://github.com/sapegin/dotfiles

import path from 'node:path';
import fs from 'node:fs/promises';
import os from 'node:os';
import sharp from 'sharp';
import YAML from 'yaml';

const VAULT_DIR = path.join(os.homedir(), 'sewer');
const TRASH_DIR = path.join(os.homedir(), 'obsidian-trash');
const LOG_DIR = path.join(VAULT_DIR, 'ðŸ“† Log');
const MAX_DIMENSION = 4096;
const MAX_FILE_SIZE = 2 * 1024 * 1024; // 2 MB
const AVIF_QUALITY = 80;
const ALL_MARKDOWN_PATTERN = `**/*.md`;
const ALL_IMAGES_PATTERN = `**/*.{png,jpg,jpeg,gif,webp,avif,bmp,tiff}`;

async function moveToTrash(filePath) {
	const filename = path.basename(filePath);
	const trashPath = path.join(TRASH_DIR, filename);

	// Handle duplicate filenames in trash
	let finalTrashPath = trashPath;
	let counter = 1;
	while (true) {
		try {
			await fs.access(finalTrashPath);
			const ext = path.extname(filename);
			const nameWithoutExt = path.basename(filename, ext);
			finalTrashPath = path.join(
				TRASH_DIR,
				`${nameWithoutExt}-${counter}${ext}`
			);
			counter++;
		} catch {
			break;
		}
	}

	await fs.rename(filePath, finalTrashPath);
	console.log(`  Move ${filename} to trash`);
}

async function getUsedImages(markdownFiles) {
	const usedImages = new Set();
	const imageRegex = /!\[.*?\]\(([^)]+)\)/g;

	for (const file of markdownFiles) {
		const content = await fs.readFile(file, 'utf-8');
		const matches = content.matchAll(imageRegex);

		for (const match of matches) {
			// Extract just the filename and decode URL encoding
			const decoded = decodeURIComponent(path.basename(match[1])).normalize(
				'NFC'
			);
			usedImages.add(decoded);
		}
	}

	return usedImages;
}

async function removeUnusedImages(imageFiles, usedImages) {
	let removedCount = 0;

	for (const imagePath of imageFiles) {
		const filename = path.basename(imagePath).normalize('NFC');

		if (usedImages.has(filename) === false) {
			await moveToTrash(imagePath);
			removedCount++;
		}
	}

	if (removedCount > 0) {
		console.log(`\n[OBSIDIAN] Removed ${removedCount} unused image(s)`);
	}
}

async function getImageDimensions(imagePath) {
	const metadata = await sharp(imagePath).metadata();
	return { width: metadata.width, height: metadata.height };
}

async function needsOptimization(imagePath) {
	const ext = path.extname(imagePath).toLowerCase();
	const stats = await fs.stat(imagePath);
	const { width, height } = await getImageDimensions(imagePath);

	if (
		// Check if the file size is too large
		(ext !== '.avif' && stats.size > MAX_FILE_SIZE) ||
		// Check if the image dimensions exceed allowed
		width > MAX_DIMENSION ||
		height > MAX_DIMENSION
	) {
		return { width, height };
	}

	return undefined;
}

async function optimizeImage(imagePath, optimization) {
	const { width, height } = optimization;
	const filename = path.basename(imagePath);
	const nameWithoutExt = path.basename(filename, path.extname(filename));
	const dir = path.dirname(imagePath);
	const avifPath = path.join(dir, `${nameWithoutExt}.avif`);

	// Calculate new dimensions if needed
	let newWidth = width;
	let newHeight = height;

	if (width > MAX_DIMENSION || height > MAX_DIMENSION) {
		if (width > height) {
			newWidth = MAX_DIMENSION;
			newHeight = Math.round(height * (MAX_DIMENSION / width));
		} else {
			newHeight = MAX_DIMENSION;
			newWidth = Math.round(width * (MAX_DIMENSION / height));
		}
	}

	// Convert and optimize
	let sharpInstance = sharp(imagePath);

	if (newWidth !== width || newHeight !== height) {
		sharpInstance = sharpInstance.resize(newWidth, newHeight, {
			fit: 'inside',
			withoutEnlargement: true,
		});
	}

	await sharpInstance.avif({ quality: AVIF_QUALITY }).toFile(avifPath);

	const originalSize = (await fs.stat(imagePath)).size;
	const optimizedSize = (await fs.stat(avifPath)).size;

	// Only keep the optimized version if it's smaller
	if (optimizedSize >= originalSize) {
		await fs.unlink(avifPath);
		console.log(
			`[OBSIDIAN] Skipped ${filename} (AVIF not smaller: ${(optimizedSize / 1024 / 1024).toFixed(2)} MB vs ${(originalSize / 1024 / 1024).toFixed(2)} MB)`
		);
		return undefined;
	}

	const savedBytes = originalSize - optimizedSize;
	const savedPercentage = ((savedBytes / originalSize) * 100).toFixed(2);

	console.log();
	console.log(`${filename} â†’ ${nameWithoutExt}.avif`);
	console.log(
		`  ${(originalSize / 1024 / 1024).toFixed(2)} MB â†’ ${(optimizedSize / 1024 / 1024).toFixed(2)} MB (saved ${savedPercentage}%)`
	);

	if (newWidth !== width || newHeight !== height) {
		console.log(
			`  Resized from ${width}Ã—${height} to ${newWidth}Ã—${newHeight}`
		);
	}

	// Move original to trash
	await moveToTrash(imagePath);

	return { oldFilename: filename, newFilename: `${nameWithoutExt}.avif` };
}

async function updateMarkdownLinks(markdownFiles, oldFilename, newFilename) {
	for (const file of markdownFiles) {
		let originalContent = await fs.readFile(file, 'utf-8');

		// Match image links with various path formats (both URL-encoded and non-encoded)
		const escapedOldFilename = oldFilename.replace(
			/[.*+?^${}()|[\]\\]/g,
			'\\$&'
		);
		const escapedOldFilenameEncoded = encodeURIComponent(oldFilename).replace(
			/[.*+?^${}()|[\]\\]/g,
			'\\$&'
		);
		const regex = new RegExp(
			`!\\[([^\\]]*)\\]\\(([^)]*(${escapedOldFilename}|${escapedOldFilenameEncoded}))\\)`,
			'g'
		);

		const basename = path.basename(file);
		const escapedNewFilename = encodeURIComponent(newFilename);
		const content = originalContent.replace(regex, (match, alt, fullPath) => {
			console.log(
				`  Update link ${fullPath} â†’ ${escapedNewFilename} in ${basename}`
			);
			return `![${alt}](${escapedNewFilename})`;
		});

		if (content !== originalContent) {
			await fs.writeFile(file, content, 'utf-8');
		}
	}
}

async function optimizeImages(imageFiles, markdownFiles) {
	let optimizedCount = 0;

	for (const imagePath of imageFiles) {
		const optimization = await needsOptimization(imagePath);

		if (optimization) {
			const result = await optimizeImage(imagePath, optimization);
			if (result) {
				const { oldFilename, newFilename } = result;
				await updateMarkdownLinks(markdownFiles, oldFilename, newFilename);
				optimizedCount++;
			}
		}
	}

	if (optimizedCount > 0) {
		console.log(`\n[OBSIDIAN] Optimized ${optimizedCount} image(s)`);
	} else {
		console.log('\n[OBSIDIAN] No images need optimization');
	}
}

function parseFrontmatter(content) {
	const match = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
	if (!match) {
		return { frontmatter: '', body: content };
	}

	const frontmatterText = match[1];
	const body = match[2];
	const frontmatter = YAML.parse(frontmatterText);

	return { frontmatter, body };
}

function serializeFrontmatter(frontmatter) {
	const yamlContent = YAML.stringify(frontmatter, undefined, {
		// Don't wrap long lines
		lineWidth: 0,
	});
	return `---\n${yamlContent.trim()}\n---`;
}

function getFirstImage(body) {
	const imageRegex = /!\[.*?\]\(([^)]+)\)/;
	const match = body.match(imageRegex);
	return match ? path.basename(decodeURIComponent(match[1])) : undefined;
}

function getExcerpt(body) {
	const textOnly = body
		// Remove headings
		.replace(/^#.*/gm, '')
		// Remove images
		.replace(/!\[.*?\]\([^)]+\)/g, '')
		// Remove links
		.replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
		.replace(/\[\[([^\]]+)\]\]/g, '$1')
		.replace(/https?:\/\/.*/g, '')
		// Remove code snippets
		.replace(/```.*?```/gm, '')
		// Remove markup
		.replace(/[*_>~`]/g, '')
		// Join lines
		.replace(/\n/gm, ' ')
		// Clean up
		.replace(/\s+/g, ' ')
		.trim();

	const match = textOnly.match(/.{300}[^ ]*/);
	return match ? `${match[0].replace(/[\.,!?â€¦\(\)]$/, '')}â€¦` : textOnly;
}

async function updateJournalFile(filePath) {
	const content = await fs.readFile(filePath, 'utf-8');
	const { frontmatter, body } = parseFrontmatter(content);

	if (frontmatter === '') {
		return;
	}

	const firstImage = getFirstImage(body);
	if (firstImage) {
		frontmatter.image = firstImage;
	}

	frontmatter.excerpt = getExcerpt(body);

	const newContent = `${serializeFrontmatter(frontmatter)}\n${body}`;

	await fs.writeFile(filePath, newContent, 'utf-8');
}

async function updateJournalEntries() {
	const journalFiles = await Array.fromAsync(
		fs.glob(path.join(LOG_DIR, ALL_MARKDOWN_PATTERN))
	);
	console.log(`[OBSIDIAN] Found ${journalFiles.length} journal entries`);

	for (const file of journalFiles) {
		await updateJournalFile(file);
	}
}

async function main() {
	console.log();
	console.log('[OBSIDIAN] Optimizing vault imagesâ€¦ ðŸ§ ');

	try {
		await fs.access(VAULT_DIR);
	} catch (error) {
		console.error();
		console.error(
			'[OBSIDIAN] Error: Vault directory does not exist:',
			VAULT_DIR
		);
		console.error();
		console.error('Create a symlink:');
		console.error(
			`ln -s ~/Library/Mobile\\ Documents/iCloud~md~obsidian/Documents/Sewer ~/sewer`
		);
		process.exit(1);
	}

	await fs.mkdir(TRASH_DIR, { recursive: true });

	console.log('\n[OBSIDIAN] Gathering the filesâ€¦');

	const markdownFiles = await Array.fromAsync(
		fs.glob(path.join(VAULT_DIR, ALL_MARKDOWN_PATTERN))
	);
	console.log(`[OBSIDIAN] Found ${markdownFiles.length} Markdown files`);

	const imageFiles = await Array.fromAsync(
		fs.glob(path.join(VAULT_DIR, ALL_IMAGES_PATTERN))
	);
	console.log(`[OBSIDIAN] Found ${imageFiles.length} images`);

	console.log('\n[OBSIDIAN] Collecting used images from Markdownâ€¦');
	const usedImages = await getUsedImages(markdownFiles);
	console.log(`[OBSIDIAN] Found ${usedImages.size} used images`);

	console.log('\n[OBSIDIAN] Removing unused imagesâ€¦');
	await removeUnusedImages(imageFiles, usedImages);

	console.log('\n[OBSIDIAN] Optimizing imagesâ€¦');
	const remainingImageFiles = await Array.fromAsync(
		fs.glob(path.join(VAULT_DIR, ALL_IMAGES_PATTERN))
	);
	// await optimizeImages(remainingImageFiles, markdownFiles);

	console.log('\n[OBSIDIAN] Updating journal entriesâ€¦');
	await updateJournalEntries();

	console.log();
	console.log('[OBSIDIAN] Done ðŸ¦œ');
}

main().catch((error) => {
	console.error();
	console.error('[OBSIDIAN] Error:', error.message);
	process.exit(1);
});
