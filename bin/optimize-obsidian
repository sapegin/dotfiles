#!/usr/bin/env node

// Optimizes images in Obsidian vault: removes unused images, converts large
// PNG files to AVIF, and downsizes oversized images. Also cleans up journal
// entries frontmatter.
//
// ---
// Author: Artem Sapegin, sapegin.me
// License: MIT
// https://github.com/sapegin/dotfiles

import path from 'node:path';
import fs from 'node:fs/promises';
import os from 'node:os';
import sharp from 'sharp';
import YAML from 'yaml';

const VAULT_DIR = path.join(os.homedir(), 'sewer');
const TRASH_DIR = path.join(os.homedir(), 'obsidian-trash');
const MAX_DIMENSION = 4096;
const MAX_FILE_SIZE = 2 * 1024 * 1024; // 2 MB
const AVIF_QUALITY = 80;
const ALL_IMAGES_PATTERN = `**/*.{png,jpg,jpeg,gif,webp,avif,bmp,tiff}`;
const ALL_NOTES_PATTERN = `**/*.md`;

async function moveToTrash(filePath) {
	const filename = path.basename(filePath);
	const trashPath = path.join(TRASH_DIR, filename);

	// Handle duplicate filenames in trash
	let finalTrashPath = trashPath;
	let counter = 1;
	while (true) {
		try {
			await fs.access(finalTrashPath);
			const ext = path.extname(filename);
			const nameWithoutExt = path.basename(filename, ext);
			finalTrashPath = path.join(
				TRASH_DIR,
				`${nameWithoutExt}-${counter}${ext}`
			);
			counter++;
		} catch {
			break;
		}
	}

	await fs.rename(filePath, finalTrashPath);
	console.log(`  Move ${filename} to trash`);
}

async function getUsedImages(markdownFiles) {
	const usedImages = new Set();
	const imageRegex = /!\[.*?\]\(([^)]+)\)/g;

	for (const file of markdownFiles) {
		const content = await fs.readFile(file, 'utf-8');
		const matches = content.matchAll(imageRegex);

		for (const match of matches) {
			// Extract just the filename and decode URL encoding
			const decoded = decodeURIComponent(path.basename(match[1])).normalize(
				'NFC'
			);
			usedImages.add(decoded);
		}
	}

	return usedImages;
}

async function removeUnusedImages(imageFiles, usedImages) {
	let removedCount = 0;

	for (const imagePath of imageFiles) {
		const filename = path.basename(imagePath).normalize('NFC');

		if (usedImages.has(filename) === false) {
			await moveToTrash(imagePath);
			removedCount++;
		}
	}

	if (removedCount > 0) {
		console.log(`\nRemoved ${removedCount} unused images`);
	}
}

async function getImageDimensions(imagePath) {
	const metadata = await sharp(imagePath).metadata();
	return { width: metadata.width, height: metadata.height };
}

async function needsOptimization(imagePath) {
	const ext = path.extname(imagePath).toLowerCase();
	const stats = await fs.stat(imagePath);
	const { width, height } = await getImageDimensions(imagePath);

	if (
		// Check if the file size is too large
		(ext !== '.avif' && stats.size > MAX_FILE_SIZE) ||
		// Check if the image dimensions exceed allowed
		width > MAX_DIMENSION ||
		height > MAX_DIMENSION
	) {
		return { width, height };
	}

	return undefined;
}

async function optimizeImage(imagePath, optimization) {
	const { width, height } = optimization;
	const filename = path.basename(imagePath);
	const nameWithoutExt = path.basename(filename, path.extname(filename));
	const dir = path.dirname(imagePath);
	const avifPath = path.join(dir, `${nameWithoutExt}.avif`);

	// Calculate new dimensions if needed
	let newWidth = width;
	let newHeight = height;

	if (width > MAX_DIMENSION || height > MAX_DIMENSION) {
		if (width > height) {
			newWidth = MAX_DIMENSION;
			newHeight = Math.round(height * (MAX_DIMENSION / width));
		} else {
			newHeight = MAX_DIMENSION;
			newWidth = Math.round(width * (MAX_DIMENSION / height));
		}
	}

	// Convert and optimize
	let sharpInstance = sharp(imagePath);

	if (newWidth !== width || newHeight !== height) {
		sharpInstance = sharpInstance.resize(newWidth, newHeight, {
			fit: 'inside',
			withoutEnlargement: true,
		});
	}

	await sharpInstance.avif({ quality: AVIF_QUALITY }).toFile(avifPath);

	const originalSize = (await fs.stat(imagePath)).size;
	const optimizedSize = (await fs.stat(avifPath)).size;

	// Only keep the optimized version if it's smaller
	if (optimizedSize >= originalSize) {
		await fs.unlink(avifPath);
		console.log(
			`Skipped ${filename} (AVIF not smaller: ${(optimizedSize / 1024 / 1024).toFixed(2)} MB vs ${(originalSize / 1024 / 1024).toFixed(2)} MB)`
		);
		return undefined;
	}

	const savedBytes = originalSize - optimizedSize;
	const savedPercentage = ((savedBytes / originalSize) * 100).toFixed(2);

	console.log();
	console.log(`${filename} â†’ ${nameWithoutExt}.avif`);
	console.log(
		`  ${(originalSize / 1024 / 1024).toFixed(2)} MB â†’ ${(optimizedSize / 1024 / 1024).toFixed(2)} MB (saved ${savedPercentage}%)`
	);

	if (newWidth !== width || newHeight !== height) {
		console.log(
			`  Resized from ${width}Ã—${height} to ${newWidth}Ã—${newHeight}`
		);
	}

	// Move original to trash
	await moveToTrash(imagePath);

	return { oldFilename: filename, newFilename: `${nameWithoutExt}.avif` };
}

async function updateMarkdownLinks(markdownFiles, oldFilename, newFilename) {
	for (const file of markdownFiles) {
		let originalContent = await fs.readFile(file, 'utf-8');

		// Match image links with various path formats (both URL-encoded and non-encoded)
		const escapedOldFilename = oldFilename.replace(
			/[.*+?^${}()|[\]\\]/g,
			'\\$&'
		);
		const escapedOldFilenameEncoded = encodeURIComponent(oldFilename).replace(
			/[.*+?^${}()|[\]\\]/g,
			'\\$&'
		);
		const regex = new RegExp(
			`!\\[([^\\]]*)\\]\\(([^)]*(${escapedOldFilename}|${escapedOldFilenameEncoded}))\\)`,
			'g'
		);

		const basename = path.basename(file);
		const escapedNewFilename = encodeURIComponent(newFilename);
		const content = originalContent.replace(regex, (match, alt, fullPath) => {
			console.log(
				`  Update link ${fullPath} â†’ ${escapedNewFilename} in ${basename}`
			);
			return `![${alt}](${escapedNewFilename})`;
		});

		if (content !== originalContent) {
			await fs.writeFile(file, content, 'utf-8');
		}
	}
}

async function optimizeImages(imageFiles, markdownFiles) {
	let optimizedCount = 0;

	for (const imagePath of imageFiles) {
		const optimization = await needsOptimization(imagePath);

		if (optimization) {
			const result = await optimizeImage(imagePath, optimization);
			if (result) {
				const { oldFilename, newFilename } = result;
				await updateMarkdownLinks(markdownFiles, oldFilename, newFilename);
				optimizedCount++;
			}
		}
	}

	console.log(`\nOptimized ${optimizedCount} images`);
}

function parseFrontmatter(content) {
	const match = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
	if (!match) {
		return { frontmatter: '', body: content };
	}

	const frontmatterText = match[1];
	const body = match[2];
	const frontmatter = YAML.parse(frontmatterText);

	return { frontmatter, body };
}

function serializeFrontmatter(frontmatter) {
	const yamlContent = YAML.stringify(frontmatter, undefined, {
		// Don't wrap long lines
		lineWidth: 0,
	});
	return `---\n${yamlContent.trim()}\n---`;
}

function getFirstImage(body) {
	const imageRegex = /!\[.*?\]\(([^)]+)\)/;
	const match = body.match(imageRegex);
	return match ? path.basename(decodeURIComponent(match[1])) : undefined;
}

function getExcerpt(body) {
	const textOnly = body
		// Remove headings
		.replace(/^#.*/gm, '')
		// Remove images
		.replace(/!\[.*?\]\([^)]+\)/g, '')
		// Remove links
		.replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
		.replace(/\[\[([^\]]+)\]\]/g, '$1')
		.replace(/https?:\/\/.*/g, '')
		// Remove code snippets
		.replace(/```.*?```/gm, '')
		// Remove markup
		.replace(/[*_>~`]/g, '')
		// Join lines
		.replace(/\n/gm, ' ')
		// Clean up
		.replace(/\s+/g, ' ')
		.trim();

	const match = textOnly.match(/.{300}[^ ]*/);
	return match ? `${match[0].replace(/[\.,!?â€¦\(\)]$/, '')}â€¦` : textOnly;
}

async function updateImages() {
	console.log('\nðŸ“¸ Updating imagesâ€¦');

	await fs.mkdir(TRASH_DIR, { recursive: true });

	console.log('\nGathering the filesâ€¦');
	const markdownFiles = await Array.fromAsync(
		fs.glob(path.join(VAULT_DIR, ALL_NOTES_PATTERN))
	);
	const imageFiles = await Array.fromAsync(
		fs.glob(path.join(VAULT_DIR, ALL_IMAGES_PATTERN))
	);
	console.log(
		`Found ${markdownFiles.length} notes and ${imageFiles.length} images`
	);

	console.log('\nCollecting used images from Markdownâ€¦');
	const usedImages = await getUsedImages(markdownFiles);
	console.log(`Found ${usedImages.size} used images`);

	console.log('\nRemoving unused imagesâ€¦');
	await removeUnusedImages(imageFiles, usedImages);

	console.log('\nOptimizing imagesâ€¦');
	const remainingImageFiles = await Array.fromAsync(
		fs.glob(path.join(VAULT_DIR, ALL_IMAGES_PATTERN))
	);
	// await optimizeImages(remainingImageFiles, markdownFiles);
}

async function updateFrontmatter(frontmatter, body, file) {
	// Only process journal notes
	if (frontmatter === '' || file.includes('ðŸ“† Log/') === false) {
		return frontmatter;
	}

	const newFrontmatter = { ...frontmatter };

	// Set `image` field to the first image of the note
	const firstImage = getFirstImage(body);
	if (firstImage) {
		newFrontmatter.image = firstImage;
	}

	// Set `excerpt` field
	newFrontmatter.excerpt = getExcerpt(body);

	return newFrontmatter;
}

async function updateNotes() {
	console.log('\nðŸ“ Updating notesâ€¦');

	let updatedCount = 0;

	const noteFiles = await Array.fromAsync(
		fs.glob(path.join(VAULT_DIR, ALL_NOTES_PATTERN))
	);
	console.log(`\nFound ${noteFiles.length} notes`);

	for (const file of noteFiles) {
		const content = await fs.readFile(file, 'utf-8');
		const { frontmatter, body } = parseFrontmatter(content);

		const newFrontmatter = updateFrontmatter(frontmatter, body, file);

		const newContent = `${serializeFrontmatter(frontmatter)}\n${body}`;
		if (newContent !== content) {
			updatedCount++;
			await fs.writeFile(file, newContent, 'utf-8');
		}
	}

	console.log(`\nUpdated ${updatedCount} notes`);
}

async function main() {
	try {
		await fs.access(VAULT_DIR);
	} catch (error) {
		console.error();
		console.error('Error: Vault directory does not exist:', VAULT_DIR);
		process.exit(1);
	}

	await updateImages();
	await updateNotes();

	console.log();
	console.log('Done ðŸ¦œ');
}

main().catch((error) => {
	console.error();
	console.error('Error:', error.message);
	process.exit(1);
});
