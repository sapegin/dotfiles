#!/usr/bin/env node

// Optimizes Obsidian vault:
// * Downscales and compress images
// * Removes unused images
// * Updates frontmatters
// * etc.
//
// ---
// Author: Artem Sapegin, sapegin.me
// License: MIT
// https://github.com/sapegin/dotfiles

// TODO: Detect missing photos with https:// and show a different error message
// TODO: Detect incorrect note properties

import path from 'node:path';
import fs from 'node:fs/promises';
import os from 'node:os';
import sharp from 'sharp';
import YAML from 'yaml';
import ExifReader from 'exifreader';

const VAULT_DIR = path.join(os.homedir(), 'murder');
const ATTACHMENTS_DIR = path.join(VAULT_DIR, 'attachments');
const TRASH_DIR = path.join(os.homedir(), 'obsidian-trash');
const MAX_DIMENSION = 2048;
const MAX_FILE_SIZE = 1024 * 1024; // 1 MB
const MAX_LARGE_FILE_SIZE = MAX_FILE_SIZE * 0.5; // 0.5 MB
const AVIF_QUALITY = 75;
const IMAGE_EXTENSIONS = [
	'.bmp',
	'.gif',
	'.heic',
	'.jpeg',
	'.jpg',
	'.mov',
	'.png',
	'.tiff',
	'.webp',
];
const ALL_IMAGE_EXTENSIONS = [...IMAGE_EXTENSIONS, '.avif'];
const ALL_EXTENSIONS = [...ALL_IMAGE_EXTENSIONS, '.md'];
const ALL_IMAGES_PATTERN = `**/*.{${ALL_IMAGE_EXTENSIONS.map((ext) => ext.slice(1)).join(',')}}`;
const ALL_NOTES_PATTERN = `**/*.md`;

// Either regular Markdown images (![Alt text](image.ext)`), or Obsidian images
// with optional resizing pipe (`![[image.png|100]]`)
const imageRegex = /!\[.*?\]\(([^)]+)\)|!\[\[([^\]]+)\]\]/g;

// WMO Weather interpretation codes
const WMO_WEATHER_CODES = {
	0: 'sunny',
	1: 'mainly sunny',
	2: 'partly cloudy',
	3: 'overcast',
	45: 'fog',
	48: 'depositing rime fog',
	51: 'light drizzle',
	53: 'moderate drizzle',
	55: 'dense drizzle',
	56: 'light freezing drizzle',
	57: 'dense freezing drizzle',
	61: 'slight rain',
	63: 'moderate rain',
	65: 'heavy rain',
	66: 'light freezing rain',
	67: 'heavy freezing rain',
	71: 'slight snow',
	73: 'moderate snow',
	75: 'fucking lots of snow',
	77: 'snow grains',
	80: 'slight rain showers',
	81: 'moderate rain showers',
	82: 'violent rain showers',
	85: 'slight snow showers',
	86: 'heavy snow showers',
	95: 'thunderstorm',
	96: 'thunderstorm with slight hail',
	99: 'thunderstorm with heavy hail',
};
const WMO_WEATHER_CODES_NIGHT = {
	0: 'clear',
	1: 'mainly clear',
};

function parseNoteDate(basename) {
	// Parse datetime from basename (format: YYYY-MM-DD_HHmm)
	const datetimeMatch = basename.match(/^(\d{4}-\d{2}-\d{2})_(\d{2})(\d{2})$/);
	if (datetimeMatch) {
		const [, date, hour, minute] = datetimeMatch;
		return new Date(Date.parse(`${date}T${hour}:${minute}:00`));
	} else {
		console.error('âš ï¸ Cannot parse date for', basename);
	}
	return undefined;
}

/** Strip known extension (image file or Markdown) from a file path. */
function stripExtension(filePath) {
	let newFilePath = filePath;
	for (const ext of ALL_EXTENSIONS) {
		if (newFilePath.toLowerCase().endsWith(ext)) {
			newFilePath = newFilePath.slice(0, -ext.length);
		}
	}
	return newFilePath;
}

/** File basename that supports multiple (known) extensions. */
function getBasename(filePath) {
	const filename = path.basename(filePath);
	return stripExtension(stripExtension(filename));
}

async function moveToTrash(filePath) {
	const filename = path.basename(filePath);
	const trashPath = path.join(TRASH_DIR, filename);

	// Handle duplicate filenames in trash
	let finalTrashPath = trashPath;
	let counter = 1;
	while (true) {
		try {
			await fs.access(finalTrashPath);
			const ext = path.extname(filename);
			const nameWithoutExt = path.basename(filename, ext);
			finalTrashPath = path.join(
				TRASH_DIR,
				`${nameWithoutExt}-${counter}${ext}`
			);
			counter++;
		} catch {
			break;
		}
	}

	await fs.rename(filePath, finalTrashPath);
	console.log(`  Move ${filename} to trash`);
}

/** Return all images in Markdown */
function getMarkdownImages(body) {
	const matches = Array.from(body.matchAll(imageRegex));
	return matches.map((match) => {
		const filePath = match[1] || match[2];
		// Extract just the filename, remove Obsidian's resizing pipe
		// (`image.png|100`), and decode URL encoding
		const cleanFilePath = filePath.split('|')[0];
		return decodeURIComponent(path.basename(cleanFilePath)).normalize('NFC');
	});
}

/** Return basename of the given image in Markdown. */
function getImageByIndex(body, index) {
	const images = getMarkdownImages(body);
	return images.length > 0 ? path.basename(images[index]) : undefined;
}

/** Calculate decimal coordinate from EXIF GPS data. */
function getGpsCoordinate(exif, type) {
	const tag = exif[`GPS${type}`];
	const ref = exif[`GPS${type}Ref`];
	if (tag === undefined || ref === undefined) {
		return undefined;
	}

	const value = tag.value;
	const refValue = ref.value[0];

	const calculate = (v) => {
		if (Array.isArray(v) && v.length === 2 && v[1] !== 0) {
			return v[0] / v[1];
		}
		return 0;
	};

	const degrees = calculate(value[0]);
	const minutes = calculate(value[1]);
	const seconds = calculate(value[2]);

	let coordinate = degrees + minutes / 60 + seconds / 3600;

	if (refValue === 'S' || refValue === 'W') {
		coordinate = -coordinate;
	}

	return coordinate;
}

/** Fetch weather data from Open-Meteo API. */
async function getWeather(lat, lon, date) {
	try {
		const isoDateString = date.toISOString();
		const dateString = isoDateString.slice(0, 10); // YYYY-MM-DD
		const hourString = isoDateString.slice(11, 13); // HH

		// Determine if we need historical or current API
		const threeMonthsAgo = new Date();
		threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
		const isHistorical = date < threeMonthsAgo;
		const baseUrl = isHistorical
			? 'https://archive-api.open-meteo.com/v1/archive'
			: 'https://api.open-meteo.com/v1/forecast';

		const params = new URLSearchParams({
			latitude: lat,
			longitude: lon,
			start_date: dateString,
			end_date: dateString,
			hourly: 'temperature_2m,weather_code,is_day',
			timezone: 'auto',
		});

		const response = await fetch(`${baseUrl}?${params}`);
		if (response.ok === false) {
			return undefined;
		}

		const data = await response.json();

		// Find the closest hour
		const hourIndex = data.hourly.time.findIndex((time) =>
			time.startsWith(`${dateString}T${hourString}`)
		);

		if (hourIndex === -1) {
			return undefined;
		}

		const temperature = Math.round(data.hourly.temperature_2m[hourIndex]);
		const weatherCode = data.hourly.weather_code[hourIndex];
		const isDay = data.hourly.is_day[hourIndex];

		let condition = WMO_WEATHER_CODES[weatherCode];
		if (isDay === 0 && WMO_WEATHER_CODES_NIGHT[weatherCode]) {
			condition = WMO_WEATHER_CODES_NIGHT[weatherCode];
		}

		const weather = condition
			? `${temperature}Â°C, ${condition}`
			: `${temperature}Â°C`;

		console.log(`  â†ª ${weather}`);

		return weather;
	} catch (error) {
		console.error('âš ï¸ Cannot fetch weather for', lat, lon, date);
		console.error(error.message);
		return undefined;
	}
}

/** Read EXIF photo metadata. */
async function getImageMetadata(filename) {
	if (!filename) {
		return { date: '', coordinates: undefined };
	}

	let filePath = path.join(ATTACHMENTS_DIR, filename);
	const ext = path.extname(filename).toLowerCase();

	// If the image isn't JPEG, look for the original JPEG file in the trash
	if (ext !== '.jpg' && ext !== '.jpeg') {
		const nameWithoutExt = path.basename(filename, ext);
		const jpegFiles = await Array.fromAsync(
			fs.glob(path.join(TRASH_DIR, `${nameWithoutExt}.{jpg,jpeg,JPG,JPEG}`))
		);
		if (jpegFiles.length > 0) {
			filePath = jpegFiles[0];
		} else {
			// Can't do anything, only JPEG files have metadata
			return { date: '', coordinates: undefined };
		}
	}

	// Check if file exists
	try {
		await fs.access(filePath);
	} catch {
		return { date: '', coordinates: undefined };
	}

	const buffer = await fs.readFile(filePath);
	const exif = ExifReader.load(buffer);

	const date = exif.DateTimeOriginal?.description ?? '';

	const lat = getGpsCoordinate(exif, 'Latitude');
	const lon = getGpsCoordinate(exif, 'Longitude');

	let coordinates;
	if (lat !== undefined && lon !== undefined) {
		coordinates = `${lat.toFixed(10)}, ${lon.toFixed(10)}`;
	}

	return { date, coordinates };
}

async function findUsedImages(markdownFiles) {
	const usedImages = new Set();

	for (const file of markdownFiles) {
		const content = await fs.readFile(file, 'utf-8');
		for (const image of getMarkdownImages(content)) {
			usedImages.add(image);
		}
	}

	return usedImages;
}

async function removeUnusedImages(imageFiles, usedImages) {
	let removedCount = 0;

	for (const imagePath of imageFiles) {
		const filename = path.basename(imagePath).normalize('NFC');

		if (usedImages.has(filename) === false) {
			await moveToTrash(imagePath);
			removedCount++;
		}
	}

	if (removedCount > 0) {
		console.log(`\nRemoved ${removedCount} unused images`);
	}
}

async function getImageDimensions(imagePath) {
	try {
		const metadata = await sharp(imagePath).metadata();
		return { width: metadata.width, height: metadata.height };
	} catch (error) {
		console.error(
			`âš ï¸ Error reading image dimensions of ${getBasename(imagePath)}:`
		);
		console.error(error.stack);
		return { width: 0, height: 0 };
	}
}

async function needsOptimization(imagePath) {
	const ext = path.extname(imagePath).toLowerCase();
	const stats = await fs.stat(imagePath);
	const dimensions = await getImageDimensions(imagePath);

	// File size is too large
	if (stats.size > MAX_FILE_SIZE) {
		return dimensions;
	}

	if (
		// Image dimensions exceed allowed
		(dimensions.width > MAX_DIMENSION || dimensions.height > MAX_DIMENSION) &&
		// But skip small sizes where optimizations is unlikely to produce smaller file
		stats.size > MAX_LARGE_FILE_SIZE
	) {
		return dimensions;
	}

	// File doesn't need optimization
	return undefined;
}

async function optimizeImage(imagePath, optimization) {
	const { width, height } = optimization;
	const filename = path.basename(imagePath);
	const dir = path.dirname(imagePath);

	// Strip all image extensions to avoid conflicts (e.g., file.jpg.webp â†’ file)
	let nameWithoutExt = filename;
	for (const ext of ALL_IMAGE_EXTENSIONS) {
		if (nameWithoutExt.toLowerCase().endsWith(ext)) {
			nameWithoutExt = nameWithoutExt.slice(0, -ext.length);
		}
	}

	const avifPath = path.join(dir, `${nameWithoutExt}.avif`);

	// Calculate new dimensions if needed
	let newWidth = width;
	let newHeight = height;

	if (width > MAX_DIMENSION || height > MAX_DIMENSION) {
		if (width > height) {
			newWidth = MAX_DIMENSION;
			newHeight = Math.round(height * (MAX_DIMENSION / width));
		} else {
			newHeight = MAX_DIMENSION;
			newWidth = Math.round(width * (MAX_DIMENSION / height));
		}
	}

	// Convert and optimize
	let sharpInstance = sharp(imagePath);

	if (newWidth !== width || newHeight !== height) {
		sharpInstance = sharpInstance.resize(newWidth, newHeight, {
			fit: 'inside',
			withoutEnlargement: true,
		});
	}

	await sharpInstance.avif({ quality: AVIF_QUALITY }).toFile(avifPath);

	const originalSize = (await fs.stat(imagePath)).size;
	const optimizedSize = (await fs.stat(avifPath)).size;

	// Only keep the optimized version if it's smaller
	if (optimizedSize >= originalSize) {
		await fs.unlink(avifPath);
		console.log(
			`Skipped ${filename} (AVIF not smaller: ${(optimizedSize / 1024 / 1024).toFixed(2)} MB vs ${(originalSize / 1024 / 1024).toFixed(2)} MB)`
		);
		return undefined;
	}

	const savedBytes = originalSize - optimizedSize;
	const savedPercentage = ((savedBytes / originalSize) * 100).toFixed(2);

	console.log();
	console.log(`${filename} â†’ ${nameWithoutExt}.avif`);
	console.log(
		`  ${(originalSize / 1024 / 1024).toFixed(2)} MB â†’ ${(optimizedSize / 1024 / 1024).toFixed(2)} MB (saved ${savedPercentage}%)`
	);

	if (newWidth !== width || newHeight !== height) {
		console.log(
			`  Resized from ${width}Ã—${height} to ${newWidth}Ã—${newHeight}`
		);
	}

	// Move original to trash
	await moveToTrash(imagePath);

	return { oldFilename: filename, newFilename: `${nameWithoutExt}.avif` };
}

async function optimizeImages(imageFiles) {
	const renamedFiles = new Map();

	for (const imagePath of imageFiles) {
		const ext = path.extname(imagePath).toLowerCase();

		// Skip AVIF as already optimized, and HEIC/MOV as Sharp doesn't support them
		if (ext === '.avif' || ext === '.heic' || ext === '.mov') {
			continue;
		}

		const optimization = await needsOptimization(imagePath);

		if (optimization) {
			const result = await optimizeImage(imagePath, optimization);
			if (result) {
				const { oldFilename, newFilename } = result;
				renamedFiles.set(oldFilename, newFilename);
			}
		}
	}

	if (renamedFiles.size > 0) {
		console.log(`\nOptimized ${renamedFiles.size} images`);
	}
	return renamedFiles;
}

function parseFrontmatter(content) {
	const match = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
	if (!match) {
		return { frontmatter: '', body: content };
	}

	const frontmatterText = match[1];
	const body = match[2];
	const frontmatter = YAML.parse(frontmatterText);

	return { frontmatter, body };
}

function serializeFrontmatter(frontmatter) {
	const yamlContent = YAML.stringify(frontmatter, undefined, {
		// Don't wrap long lines
		lineWidth: 0,
	});
	return `---\n${yamlContent.trim()}\n---`;
}

function getExcerpt(body) {
	const textOnly = body
		// Remove headings
		.replace(/^#.*/gm, '')
		// Remove images
		.replace(/!\[.*?\]\([^)]+\)/g, '')
		.replace(/!\[\[.*?\]\]/g, '')
		// Remove links
		.replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
		.replace(/\[\[[^\]\|]+\|([^\]]+)\]\]/g, '$1')
		.replace(/\[\[([^\]]+)\]\]/g, '$1')
		.replace(/https?:\/\/.*/g, '')
		// Remove code snippets
		.replace(/```[\S\s]*?```/gm, '')
		// Remove markup
		.replace(/[*_>~`]/g, '')
		// Join lines
		.replace(/\n/gm, ' ')
		// Clean up
		.replace(/\s+/g, ' ')
		.trim();

	// Leave only very short snippet of text to avoid excerpts appearing in search
	// results too often
	const match = textOnly.match(/.{80}[^ ]*/);
	return match ? `${match[0].replace(/[\.,!?â€¦\(\)]$/, '')}â€¦` : textOnly;
}

async function updateNote({
	frontmatter,
	body,
	file,
	allNotes,
	renamedFiles,
	attachmentNames,
}) {
	const newFrontmatter = { ...frontmatter };
	let newBody = body;
	let newFile = file;

	const basename = path.basename(file, '.md');

	// Update renamed image links
	const images = getMarkdownImages(body);
	for (const image of images) {
		// Update renamed images
		if (renamedFiles.has(image)) {
			const newFilename = renamedFiles.get(image);

			console.log(
				`  Updating image links: ${getBasename(image)} â†’ ${getBasename(newFilename)}`
			);

			const escapedOldFilename = RegExp.escape(image);
			const escapedOldFilenameEncoded = RegExp.escape(
				encodeURIComponent(image)
			);

			// Simplified regexp to cath Markdown images (![Alt text](image.ext)`) and
			// Obsidian images with optional resizing pipe (`![[image.png|100]]`)
			const regex = new RegExp(
				`([\(\[])(${escapedOldFilename}|${escapedOldFilenameEncoded})([\)\]\|])`,
				'g'
			);
			// Update the image name in the link
			newBody = newBody.replace(regex, (_match, prefix, _image, suffix) => {
				return `${prefix}${newFilename}${suffix}`;
			});

			// Update frontmatter image field if it matches the renamed image
			if (frontmatter?.image === image) {
				newFrontmatter.image = newFilename;
			}
		}
	}

	// Check for missing images
	const updatedImages = getMarkdownImages(newBody);
	for (const image of updatedImages) {
		if (
			// Skip Obsidian Bases
			image.endsWith('.base') === false &&
			image.includes('.base#') === false &&
			// Skip embedded notes (they don't have a file extension)
			image.includes('.') === true &&
			attachmentNames.has(image) === false
		) {
			console.log(`âš ï¸  Missing image: ${image} in ${path.basename(file)}`);
		}
	}

	// Journal notes
	if (file.includes('ðŸ“† Log/') && newFrontmatter) {
		// Detect misspelled note properties
		for (const field in newFrontmatter) {
			if (
				[
					'coordinates',
					'crumbs',
					'excerpt',
					'image',
					'location',
					'source',
					'sputniks',
					'tags',
					'weather',
				].includes(field) === false
			) {
				console.error(`âš ï¸ Invalid property name â€œ${field}â€ in`, basename);
			}
		}

		// Use the updated image from frontmatter if available, otherwise take the
		// first image in the Markdown body
		const firstImage = newFrontmatter.image || getImageByIndex(newBody, 0);
		const firstImageMetadata = await getImageMetadata(firstImage);
		let { location } = frontmatter;

		// Set `image` field to the first image of the note
		if (firstImage) {
			newFrontmatter.image = firstImage;

			// Set coordinates if not set already
			if (firstImageMetadata.coordinates) {
				newFrontmatter.coordinates = firstImageMetadata.coordinates;
			}
		}

		// Set `excerpt` field
		newFrontmatter.excerpt = getExcerpt(body);

		// Update location field
		if (location && location.startsWith('[[') === false) {
			// Link notes about places if they exist in the vault
			const locationNote = allNotes.find(
				(notePath) => path.basename(notePath, '.md') === location
			);
			if (locationNote) {
				newFrontmatter.location = `[[${location}]]`;
			}
		}

		// Get the coordinates from linked location note
		if (location) {
			// Extract location name from wiki link format [[Location]] or plain text
			const locationName = location.startsWith('[[')
				? location.slice(2, -2)
				: location;

			const locationNotePath = allNotes.find(
				(notePath) => path.basename(notePath, '.md') === locationName
			);

			if (locationNotePath) {
				try {
					const locationContent = await fs.readFile(locationNotePath, 'utf-8');
					const { frontmatter: locationFrontmatter } =
						parseFrontmatter(locationContent);
					if (locationFrontmatter?.coordinates) {
						newFrontmatter.coordinates = locationFrontmatter.coordinates;
					}
				} catch (error) {
					// Ignore errors reading location note
				}
			}
		}

		// Update journal date based on the first photo. The note heading should look
		// like this: `YYYY-MM-DD?!` or `YYYY-MM-DD?! N`
		if (firstImage && /^# \d\d\d\d-\d\d-\d\d\?!/.test(body.trimStart())) {
			// Get an optional image index (default to the first image)
			const imageIndexMatch = body.match(/^# \d\d\d\d-\d\d-\d\d\?! (\d+)/);
			const imageIndex = Number(imageIndexMatch?.[1] || '1') - 1;
			console.log(`  Updating note date using image number ${imageIndex + 1}â€¦`);

			// Get the image metadata
			const image = getImageByIndex(body, imageIndex);
			const imageMetadata = await getImageMetadata(image);

			if (imageMetadata.date) {
				// EXIF date strings look like 2025:02:13 18:25:59. Convert it to filename
				// format: YYYY-MM-DD_HHss
				const newBasename = imageMetadata.date.replace(
					/^(\d{4}):(\d{2}):(\d{2}) (\d{2}):(\d{2}):(\d{2})/,
					'$1-$2-$3_$4$5'
				);

				// Update basename in the file path
				newFile = file.replace(basename, newBasename);

				// Delete existing weather info, as it should be updated for the new
				// date/time
				delete newFrontmatter.weather;
			}
		}

		// Get the date/time from the filename
		const date = parseNoteDate(path.basename(newFile, '.md'));

		// Check for missing coordinates
		if (location && newFrontmatter.coordinates === undefined) {
			console.log(
				`âš ï¸  Missing coordinates for ${location} in ${path.basename(file)}`
			);
		}

		// Fetch weather if we have coordinates and no weather field yet
		if (
			date &&
			newFrontmatter.weather === undefined &&
			newFrontmatter.coordinates
		) {
			console.log(`  Fetching weather for ${getBasename(newFile)}â€¦`);

			// Parse coordinates
			const [lat, lon] = newFrontmatter.coordinates
				.split(',')
				.map((c) => c.trim());

			const weather = await getWeather(lat, lon, date);
			if (weather) {
				newFrontmatter.weather = weather;
			}

			// Small delay to avoid hitting rate limits
			await new Promise((resolve) => setTimeout(resolve, 100));
		}

		// Update top-level headers
		const newDate = date
			? date.toLocaleDateString('en-US', {
					weekday: 'long',
					year: 'numeric',
					month: 'long',
					day: 'numeric',
				})
			: basename;

		if (newBody.trim().startsWith('# ') === false) {
			newBody = `# ${newDate}\n${newBody}`;
		} else {
			newBody = newBody.replace(/^#.*\n/, `# ${newDate}\n`);
		}
	} else {
		// Add missing top-level headers
		if (
			// Note doesn't have a first-level heading yet
			newBody.trim().startsWith('# ') === false &&
			// And it doesn't start with an icon image
			/^\!\[\[[^|]+\|icon\]\]/.test(newBody.trim()) === false
		) {
			newBody = `# ${basename}\n${newBody}`;
		}
	}

	// Cleanup whitespace only lines and multiple new lines
	newBody = newBody.replace(/^\s+$/gm, '').replace(/\n\n\n+/gm, '\n\n');

	return { newFrontmatter, newBody, newFile };
}

async function updateNotes(renamedFiles) {
	let updatedCount = 0;

	const allNotes = await Array.fromAsync(
		fs.glob(path.join(VAULT_DIR, ALL_NOTES_PATTERN))
	);

	// Gather all attachment filenames
	const imageFiles = await Array.fromAsync(
		fs.glob(path.join(VAULT_DIR, ALL_IMAGES_PATTERN))
	);
	const attachmentNames = new Set(
		imageFiles.map((imagePath) => path.basename(imagePath).normalize('NFC'))
	);

	for (const file of allNotes) {
		try {
			const content = await fs.readFile(file, 'utf-8');
			const { frontmatter, body } = parseFrontmatter(content);

			const { newFrontmatter, newBody, newFile } = await updateNote({
				frontmatter,
				body,
				file,
				allNotes,
				renamedFiles,
				attachmentNames,
			});

			const newContent =
				Object.keys(newFrontmatter).length > 0
					? `${serializeFrontmatter(newFrontmatter)}\n${newBody}`
					: newBody;

			// Update file if the contents was changed
			if (newContent !== content) {
				updatedCount++;
				await fs.writeFile(newFile, newContent, 'utf-8');
			}

			// Remove old file if the name was changed
			if (newFile !== file) {
				console.log(`  ${getBasename(file)} â†’ ${getBasename(newFile)}`);
				moveToTrash(file);
			}
		} catch (error) {
			console.error(`âš ï¸ Error updating ${file}:`);
			console.error(error.stack);
		}
	}

	console.log(`\nUpdated ${updatedCount} notes`);
}

async function main() {
	try {
		await fs.access(VAULT_DIR);
	} catch (error) {
		console.error();
		console.error('â›”ï¸ Error: Vault directory does not exist:', VAULT_DIR);
		process.exit(1);
	}

	await fs.mkdir(TRASH_DIR, { recursive: true });

	console.log('\nðŸ’¿ Gathering the filesâ€¦');
	const markdownFiles = await Array.fromAsync(
		fs.glob(path.join(VAULT_DIR, ALL_NOTES_PATTERN))
	);
	const imageFiles = await Array.fromAsync(
		fs.glob(path.join(VAULT_DIR, ALL_IMAGES_PATTERN))
	);
	console.log(
		`\nFound ${markdownFiles.length} notes and ${imageFiles.length} images`
	);

	console.log('\nðŸ“¸ Updating imagesâ€¦');

	console.log('\nOptimizing imagesâ€¦');
	const renamedFiles = await optimizeImages(imageFiles);

	console.log('\nðŸ“ Updating notesâ€¦');

	await updateNotes(renamedFiles);

	console.log('\nCollecting used images from Markdownâ€¦');
	const updatedMarkdownFiles = await Array.fromAsync(
		fs.glob(path.join(VAULT_DIR, ALL_NOTES_PATTERN))
	);
	const usedImages = await findUsedImages(updatedMarkdownFiles);
	console.log(`\nFound ${usedImages.size} image usages`);

	console.log('\nRemoving unused imagesâ€¦');
	const remainingImageFiles = await Array.fromAsync(
		fs.glob(path.join(VAULT_DIR, ALL_IMAGES_PATTERN))
	);
	await removeUnusedImages(remainingImageFiles, usedImages);

	console.log();
	console.log('Done ðŸ¦œ');
}

main().catch((error) => {
	console.log();
	console.error(error.stack);
	process.exit(1);
});
